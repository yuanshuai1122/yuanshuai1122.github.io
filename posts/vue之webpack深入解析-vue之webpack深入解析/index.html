<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Vue之webpack深入解析 - 我的 Hugo FixIt 网站</title><meta name="author" content="">
<meta name="author-link" content="">
<meta name="description" content="声明：本文转自coderwhy大佬的简书：https://www.jianshu.com/p/a83ffc6fdf1d 仅供个人学习使用，侵删" /><meta name="keywords" content='Vue' /><meta itemprop="name" content="Vue之webpack深入解析">
<meta itemprop="description" content="声明：本文转自coderwhy大佬的简书：https://www.jianshu.com/p/a83ffc6fdf1d 仅供个人学习使用，侵删">

<meta itemprop="wordCount" content="10526">
<meta itemprop="keywords" content="Vue," /><meta property="og:title" content="Vue之webpack深入解析" />
<meta property="og:description" content="声明：本文转自coderwhy大佬的简书：https://www.jianshu.com/p/a83ffc6fdf1d 仅供个人学习使用，侵删" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanshuai1122.github.com/posts/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="posts" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue之webpack深入解析"/>
<meta name="twitter:description" content="声明：本文转自coderwhy大佬的简书：https://www.jianshu.com/p/a83ffc6fdf1d 仅供个人学习使用，侵删"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://yuanshuai1122.github.com/posts/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" /><link rel="prev" href="https://yuanshuai1122.github.com/posts/vue%E4%B9%8B%E6%8F%92%E5%80%BC%E6%93%8D%E4%BD%9C-vue%E4%B9%8B%E6%8F%92%E5%80%BC%E6%93%8D%E4%BD%9C/" /><link rel="next" href="https://yuanshuai1122.github.com/posts/vue%E4%B9%8Bvuex%E4%B8%80-vue%E4%B9%8Bvuex%E4%B8%80/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Vue之webpack深入解析",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/yuanshuai1122.github.com\/posts\/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90\/"
    },"genre": "posts","keywords": "Vue","wordcount":  10526 ,
    "url": "https:\/\/yuanshuai1122.github.com\/posts\/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90\/","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "yuanshuai"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="我的 Hugo FixIt 网站"><img loading="lazy" src="/fixit.min.svg" srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" sizes="auto" data-title="我的 Hugo FixIt 网站" data-alt="我的 Hugo FixIt 网站" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">My Hugo FixIt Site</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="我的 Hugo FixIt 网站"><img loading="lazy" src="/fixit.min.svg" srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" sizes="auto" data-title="/fixit.min.svg" data-alt="/fixit.min.svg" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">My Hugo FixIt Site</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                >文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                >分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                >标签</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>Vue之webpack深入解析</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      yuanshuai</span></span></div>
      <div class="post-meta-line"><span title="发布于 0001-01-01 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden="true"></i><time datetime="0001-01-01">0001-01-01</time></span>&nbsp;<span title="更新于 0001-01-01 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden="true"></i><time datetime="0001-01-01">0001-01-01</time></span>&nbsp;<span title="10526 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 10600 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 22 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一-认识webpack">一. 认识webpack</a></li>
        <li><a href="#二-webpack起步">二. webpack起步</a></li>
        <li><a href="#三-webpack配置">三. webpack配置</a></li>
        <li><a href="#四-loader的使用">四. loader的使用</a></li>
        <li><a href="#五-集成vuejs">五. 集成Vuejs</a></li>
        <li><a href="#六-plugin的使用">六. plugin的使用</a></li>
        <li><a href="#七-搭建本地服务">七. 搭建本地服务</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>声明：本文转自coderwhy大佬的简书：https://www.jianshu.com/p/a83ffc6fdf1d</p>
<p>仅供个人学习使用，侵删。</p>
<h3 id="一-认识webpack">一. 认识webpack</h3>
<h4 id="11-webpack介绍">1.1. webpack介绍</h4>
<p>什么是webpack？</p>
<ul>
<li>这个webpack还真不是一两句话可以说清楚的。</li>
<li>我们先看看官方的解释：
<ul>
<li>At its core, <strong>webpack</strong> is a <em>static module bundler</em> for modern JavaScript applications.</li>
</ul>
</li>
<li>别和我说英文，OK？
<ul>
<li>从本质上来讲，webpack是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具。</li>
</ul>
</li>
<li>但是它是什么呢？用概念解释概念，还是不清晰。
<ul>
<li>我们从两个点来解释上面这句话。</li>
<li><strong>模块</strong> 和 <strong>打包</strong></li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/218.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/218.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/218.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/218.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/218.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/218.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>前端模块化：</p>
<ul>
<li>在学习ES6语法的时候，我已经用了大量的篇幅解释了为什么前端需要模块化。</li>
<li>而且我也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。</li>
<li>在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li>
<li>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</li>
<li>而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。</li>
<li>而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用（在后续我们会看到）。</li>
<li>这就是webpack中模块化的概念。</li>
</ul>
<p><strong>打包</strong>如何理解呢？</p>
<ul>
<li>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。</li>
<li>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。</li>
<li>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</li>
<li>但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？</li>
<li>我们稍后就会介绍到，不要着急。O(∩_∩)O~~</li>
</ul>
<h4 id="12-和gruntgulp的对比">1.2. 和grunt/gulp的对比</h4>
<p>grunt/gulp的核心是Task</p>
<ul>
<li>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）</li>
<li>之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。</li>
<li>所以grunt/gulp也被称为前端自动化任务管理工具。</li>
</ul>
<p>我们来看一个gulp的task</p>
<ul>
<li>下面的task就是将src下面的所有js文件转成ES5的语法。</li>
<li>并且最终输出到dist文件夹中。</li>
</ul>
<div class="highlight" id="id-1"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">const gulp = require(&#39;gulp&#39;);
</span></span><span class="line"><span class="cl">const babel = require(&#39;gulp-babel&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gulp.task(&#39;js&#39;, () =&gt;
</span></span><span class="line"><span class="cl">    gulp.src(&#39;src/*.js&#39;)
</span></span><span class="line"><span class="cl">        .pipe(babel({
</span></span><span class="line"><span class="cl">            presets: [&#39;es2015&#39;]
</span></span><span class="line"><span class="cl">        }))
</span></span><span class="line"><span class="cl">        .pipe(gulp.dest(&#39;dist&#39;))
</span></span><span class="line"><span class="cl">);</span></span></code></pre></div><p>什么时候用grunt/gulp呢？</p>
<ul>
<li>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。</li>
<li>只需要进行简单的合并、压缩，就使用grunt/gulp即可。</li>
<li>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。</li>
</ul>
<p>所以，grunt/gulp和webpack有什么不同呢？</p>
<ul>
<li>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</li>
<li>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</li>
</ul>
<h4 id="13-webpack安装">1.3. webpack安装</h4>
<p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm</p>
<p>查看自己的node版本：</p>
<div class="highlight" id="id-2"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">node -v</span></span></code></pre></div><p>全局安装webpack(这里我先指定版本号3.6.0，因为vue cli依赖该版本)</p>
<div class="highlight" id="id-3"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install webpack@3.6.0 -g</span></span></code></pre></div><p>后续才需要，在开发的目录中，局部安装webpack</p>
<ul>
<li>&ndash;save-dev`是开发时依赖，项目打包后不需要继续使用的。</li>
</ul>
<div class="highlight" id="id-4"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> 对应目录
</span></span><span class="line"><span class="cl">npm install webpack@3.6.0 --save-dev</span></span></code></pre></div><p>为什么全局安装后，还需要局部安装呢？</p>
<ul>
<li>在终端直接执行webpack命令，使用的全局安装的webpack</li>
<li>当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</li>
</ul>
<h3 id="二-webpack起步">二. webpack起步</h3>
<h4 id="21-准备工作">2.1. 准备工作</h4>
<p>我们创建如下文件和文件夹：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/219.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/219.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/219.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/219.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/219.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/219.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>文件和文件夹解析：</p>
<ul>
<li>dist文件夹：用于存放之后打包的文件</li>
<li>src文件夹：用于存放我们写的源文件
<ul>
<li>main.js：项目的入口文件。具体内容查看下面详情。</li>
<li>mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用。具体内容查看下面的详情。</li>
</ul>
</li>
<li>index.html：浏览器打开展示的首页html</li>
<li>package.json：通过npm init生成的，npm包管理的文件（暂时没有用上，后面才会用上）</li>
</ul>
<p>mathUtils.js文件中的代码：</p>
<ul>
<li>定义两个函数，并且通过module.exports导出</li>
</ul>
<div class="highlight" id="id-5"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">num1</span> <span class="o">*</span> <span class="nx">num2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">add</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mul</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>main.js文件中的代码：</p>
<div class="highlight" id="id-6"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">math</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./mathUtils&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello Webpack&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">mul</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span></span></span></code></pre></div><h4 id="22-js文件的打包">2.2. js文件的打包</h4>
<p>现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。</p>
<ul>
<li>因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码。</li>
<li>另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。</li>
</ul>
<p>我们应该怎么做呢？使用webpack工具，对多个js文件进行打包。</p>
<ul>
<li>我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。（如何处理的，待会儿在原理中，我会讲解）</li>
<li>另外，如果在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了。</li>
</ul>
<p>OK，如何打包呢？使用webpack的指令即可</p>
<div class="highlight" id="id-7"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">webpack src/main.js dist/bundle.js</span></span></code></pre></div><p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/220.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/220.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/220.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/220.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/220.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/220.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>打包后会在dist文件下，生成一个bundle.js文件</p>
<ul>
<li>文件内容有些复杂，这里暂时先不看，后续再进行分析。</li>
</ul>
<p>bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/222.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/222.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/222.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/222.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/222.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/222.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>打开HTML，那么就会看到我们js文件执行的结果：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/223.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/223.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/223.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/223.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/223.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/223.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="三-webpack配置">三. webpack配置</h3>
<h4 id="31-入口和出口">3.1. 入口和出口</h4>
<p>我们考虑一下，如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？</p>
<ul>
<li>当然可以，就是创建一个webpack.config.js文件</li>
</ul>
<div class="highlight" id="id-8"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 入口: 可以是字符串/数组/对象, 这里我们入口只有一个,所以写一个字符串即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">entry</span><span class="o">:</span> <span class="s1">&#39;./src/main.js&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 出口: 通常是一个对象, 里面至少包含两个重要属性, path 和 filename
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">output</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">path</span><span class="o">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">),</span> <span class="c1">// 注意: path通常是一个绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">filename</span><span class="o">:</span> <span class="s1">&#39;bundle.js&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><h4 id="32-watch">3.2. watch</h4>
<p>我现在有一个更加大胆的想法，希望src文件中的js代码发生变化时，webpack可以检测到，并且自动重新打包</p>
<ul>
<li>如果有重新打包，那么我只需要刷新一下浏览器就可以知道我修改代码后的效果了。</li>
<li>这个时候，我可以再添加一个配置watch</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/224.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/224.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/224.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/224.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/224.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/224.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>重新通过webpack终端执行一次命令，会看到如下结果：</p>
<ul>
<li>你会发现这次命令执行之后没有直接结束，而是出于监听状态。</li>
<li>当我们修改了前面的代码后，会自动重新打包。</li>
<li>可以通过ctrl+c停止监听。</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/225.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/225.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/225.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/225.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/225.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/225.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>当然，后面我们有更加方便的方式来监听代码的变化，并且可以实时在浏览器中查看。</p>
<h4 id="33-启动webpack方式">3.3. 启动webpack方式</h4>
<p>目前，我们使用的webpack是全局的webpack，如果我们想使用局部来打包呢？</p>
<ul>
<li>因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题。</li>
<li>所以通常一个项目，都有自己局部的webpack。</li>
</ul>
<p>第一步，项目中需要安装自己局部的webpack</p>
<ul>
<li>这里我们让局部安装webpack3.6.0</li>
<li>因为方便我们后续查看Vue CLI2中的webpack3.6.0配置</li>
<li>Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</li>
<li>我们在学习阶段，先使用webpack3.x即可。</li>
<li>后续开发中，我们会直接使用脚手架，CLI2和CLI3都会使用。</li>
</ul>
<div class="highlight" id="id-9"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install webpack@3.6.0 --save-dev</span></span></code></pre></div><p>第二步，通过node_modules/.bin/webpack启动webpack打包</p>
<div class="highlight" id="id-10"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">node_modules/.bin/webpack</span></span></code></pre></div><p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/226.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/226.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/226.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/226.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/226.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/226.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>但是，每次执行都敲这么一长串有没有觉得不方便呢？</p>
<ul>
<li>OK，我们可以在package.json的scripts中定义自己的执行脚本。</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/227.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/227.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/227.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/227.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/227.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/227.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<ul>
<li>首先，会寻找本地的<code>node_modules/.bin</code>路径中对应的命令。</li>
<li>如果没有找到，会去全局的环境变量中寻找。</li>
</ul>
<p>如何执行我们的build指令呢？</p>
<div class="highlight" id="id-11"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm run build</span></span></code></pre></div><p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/228.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/228.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/228.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/228.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/228.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/228.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="四-loader的使用">四. loader的使用</h3>
<blockquote>
<p>目前，webpack帮助我们处理的都是js文件。</p>
<p>但我们前面提过，webpack可以将js、图片、css都当成模块来进行处理，下面我们就来学习一下如何处理它们。</p>
</blockquote>
<h4 id="41-css文件处理">4.1. css文件处理</h4>
<h5 id="411-css准备的阶段">4.1.1. css准备的阶段</h5>
<p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。</p>
<ul>
<li>在src目录中，创建一个css文件，其中创建一个normal.css文件。</li>
<li>我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/229.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/229.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/229.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/229.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/229.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/229.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>normal.css中的代码非常简单，就是将body设置为red</p>
<div class="highlight" id="id-12"><pre tabindex="0" class="chroma"><code class="language-css" data-lang="css"><span class="line"><span class="cl"><span class="nt">body</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">background-color</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>但是，这个时候normal.css中的样式会生效吗？</p>
<ul>
<li>当然不会，因为我们压根就没有引用它。</li>
<li>webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件。</li>
</ul>
<p>在入口文件中引用：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/230.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/230.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/230.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/230.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/230.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/230.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>重新打包，会出现如下错误：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/231.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/231.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/231.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/231.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/231.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/231.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>这个错误，告诉我们要想加载css文件，必须使用对应的loader</p>
<h5 id="412-认识loader">4.1.2. 认识loader</h5>
<p>loader是webpack中一个非常核心的概念。</p>
<p>webpack用来做什么呢？</p>
<ul>
<li>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</li>
<li>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</li>
<li>对于webpack本身的能力来说，对于这些转化是不支持的。</li>
<li>那怎么办呢？给webpack扩展对应的loader就可以啦。</li>
</ul>
<p>loader使用过程：</p>
<ul>
<li>步骤一：通过npm安装需要使用的loader</li>
<li>步骤二：在<code>webpack.config.js</code>中的<code>modules</code>关键字下进行配置</li>
</ul>
<p>目前，我们希望加载和使用.css文件，就需要使用对应的loader</p>
<ul>
<li>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。</li>
</ul>
<h5 id="413-css处理的loader">4.1.3. css处理的loader</h5>
<p>在webpack的官方中，我们可以找到如下关于样式的loader使用方法：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/232.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/232.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/232.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/232.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/232.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/232.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>OK，按照教程，我们需要先安装css-loader</p>
<div class="highlight" id="id-13"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev css-loader</span></span></code></pre></div><p>按照官方配置webpack.config.js文件</p>
<ul>
<li>注意：配置中有一个style-loader，我们并不知道它是什么，所以可以暂时不进行配置。</li>
</ul>
<p>重新打包项目：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/233.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/233.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/233.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/233.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/233.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/233.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>但是，运行index.html，你会发现样式并没有生效。</p>
<ul>
<li>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。</li>
<li>这个时候，我们还需要一个style-loader帮助我们处理。</li>
</ul>
<p>我们来安装style-loader</p>
<div class="highlight" id="id-14"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev style-loader</span></span></code></pre></div><p>将对应的style-loader，配置在webpack.config.js中</p>
<ul>
<li>注意：style-loader需要放在css-loader的前面。</li>
<li>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？</li>
<li>答案：这次因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</li>
</ul>
<p>目前，webpack.config.js的配置如下：</p>
<div class="highlight" id="id-15"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 入口: 可以是字符串/数组/对象, 这里我们入口只有一个,所以写一个字符串即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">entry</span><span class="o">:</span> <span class="s1">&#39;./src/main.js&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 出口: 通常是一个对象, 里面至少包含两个重要属性, path 和 filename
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">output</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">path</span><span class="o">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">),</span> <span class="c1">// 注意: path通常是一个绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">filename</span><span class="o">:</span> <span class="s1">&#39;bundle.js&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.css$/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">use</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;style-loader&#39;</span><span class="p">,</span> <span class="s1">&#39;css-loader&#39;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>并且，现在再次运行index.html就会发现我们的样式生效了。</p>
<h4 id="42-less文件处理">4.2. less文件处理</h4>
<blockquote>
<p>如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？</p>
<p>我们这里以less为例，其他也是一样的。</p>
</blockquote>
<h5 id="412-less准备的阶段">4.1.2. less准备的阶段</h5>
<p>我们还是先创建一个less文件，依然放在css文件夹中</p>
<p>special.css文件的内容：</p>
<div class="highlight" id="id-16"><pre tabindex="0" class="chroma"><code class="language-css" data-lang="css"><span class="line"><span class="cl"><span class="p">@</span><span class="k">fontSize</span><span class="o">:</span> <span class="nt">50px</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">@</span><span class="k">fontColor</span><span class="o">:</span> <span class="nt">white</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">body</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">color</span><span class="p">:</span> <span class="o">@</span><span class="n">fontColor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">font-size</span><span class="p">:</span> <span class="o">@</span><span class="n">fontSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>为了让special.css生效，我们需要在main.js中引入</p>
<ul>
<li>另外，这里为了看到样式有生效，还在页面中写入了一个div元素</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/234.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/234.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/234.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/234.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/234.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/234.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>这个时候，打包程序，会报如下错误：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/235.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/235.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/235.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/235.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/235.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/235.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h5 id="413-less处理的loader">4.1.3. less处理的loader</h5>
<p>继续在官方中查找，我们会找到less-loader相关的使用说明</p>
<p>首先，还是需要安装对应的loader</p>
<ul>
<li>注意：我们这里还安装了less，因为webpack会使用less对less文件进行编译</li>
</ul>
<div class="highlight" id="id-17"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev less-loader less</span></span></code></pre></div><p>其次，修改对应的配置文件</p>
<ul>
<li>添加一个rules选项，用于处理.less文件</li>
</ul>
<div class="highlight" id="id-18"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.less$/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">use</span><span class="o">:</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">loader</span><span class="o">:</span> <span class="s2">&#34;style-loader&#34;</span> <span class="c1">// creates style nodes from JS strings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">loader</span><span class="o">:</span> <span class="s2">&#34;css-loader&#34;</span> <span class="c1">// translates CSS into CommonJS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">loader</span><span class="o">:</span> <span class="s2">&#34;less-loader&#34;</span> <span class="c1">// compiles Less to CSS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span></span></span></code></pre></div><h4 id="43-资源文件处理">4.3. 资源文件处理</h4>
<h5 id="431-资源准备阶段">4.3.1. 资源准备阶段</h5>
<p>首先，我们在项目中加入两张图片：</p>
<ul>
<li>一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpeg(大于8kb)</li>
<li>待会儿我们会针对这两张图片进行不同的处理</li>
</ul>
<p>我们先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：</p>
<div class="highlight" id="id-19"><pre tabindex="0" class="chroma"><code class="language-css" data-lang="css"><span class="line"><span class="cl"><span class="nt">body</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">background-color</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">background</span><span class="p">:</span> <span class="nb">url</span><span class="p">(</span><span class="sx">../imgs/test01.jpeg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>如果我们现在直接打包，会出现如下问题</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/236.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/236.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/236.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/236.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/236.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/236.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>很简单，还是没有对应的加载器</p>
<h5 id="432-url-loader">4.3.2. url-loader</h5>
<p>图片处理，我们使用url-loader来处理</p>
<p>依然先安装url-loader</p>
<div class="highlight" id="id-20"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev url-loader</span></span></code></pre></div><p>修改webpack.config.js配置文件：</p>
<div class="highlight" id="id-21"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">     <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.(png|jpg|gif|jpeg)$/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">use</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;url-loader&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">limit</span><span class="o">:</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span></span></span></code></pre></div><p>这里有一个limit选项，我们先写在这里，待会儿再来解释它的作用</p>
<p>再次打包，运行index.html，就会发现我们的背景图片选出了出来。</p>
<p>而仔细观察，你会发现背景图是通过base64显示出来的</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/237.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/237.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/237.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/237.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/237.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/237.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>OK，这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码</p>
<p>那么问题来了，如果大于8kb呢？</p>
<ul>
<li>我们将background的图片改成test02.jpg</li>
</ul>
<p>继续打包我们的程序，报错了</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/238.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/238.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/238.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/238.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/238.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/238.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader</p>
<h5 id="433-file-loader">4.3.3. file-loader</h5>
<p>当图片大于8kb时，会使用file-loader进行加载，所以我们需要先安装file-loader</p>
<ul>
<li>注：file-loader可以不进行rules的配置</li>
</ul>
<div class="highlight" id="id-22"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev file-loader</span></span></code></pre></div><p>再次打包，就会发现dist文件夹下多了一个图片文件</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/239.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/239.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/239.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/239.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/239.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/239.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>我们发现webpack自动帮助我们生成一个非常长的名字</p>
<ul>
<li>这是一个32位hash值，目的是防止名字重复</li>
<li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li>
<li>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复</li>
</ul>
<p>所以，我们可以在options中添加上如下选项：</p>
<ul>
<li>img：文件要打包到的文件夹</li>
<li>name：获取图片原来的名字，放在该位置</li>
<li>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext：使用图片原来的扩展名</li>
</ul>
<div class="highlight" id="id-23"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">limit</span><span class="o">:</span> <span class="mi">8192</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;img/[name].[hash:8].[ext]&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确</p>
<ul>
<li>默认情况下，webpack会将生成的路径直接返回给使用者</li>
<li>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/</li>
</ul>
<p>在webpack.config.js中添加如下配置：</p>
<ul>
<li>这个配置待会儿就不再需要了，我们后续再说，在这里我们必须添加上去。</li>
<li><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/240.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/240.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/240.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/240.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/240.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/240.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></li>
</ul>
<p>再次打包运行程序，一切正常了。</p>
<h4 id="44-babel-loader">4.4. babel-loader</h4>
<p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。</p>
<p>在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。</p>
<ul>
<li>而在webpack中，我们直接使用babel对应的loader就可以了。</li>
</ul>
<p>安装对应的babel-loader</p>
<div class="highlight" id="id-24"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</span></span></code></pre></div><p>配置webpack.config.js文件</p>
<div class="highlight" id="id-25"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.m?js$/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/(node_modules|bower_components)/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">use</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">presets</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;es2015&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span></span></span></code></pre></div><p>重新打包，查看bundle.js文件，发现其中的内容变成了ES5的语法</p>
<h3 id="五-集成vuejs">五. 集成Vuejs</h3>
<blockquote>
<p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。</p>
<p>所以，下面我们来学习一下如何在我们的webpack环境中集成Vuejs</p>
</blockquote>
<h4 id="51-简单使用vuejs">5.1. 简单使用Vuejs</h4>
<p>现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装</p>
<ul>
<li>注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</li>
</ul>
<div class="highlight" id="id-26"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install vue --save</span></span></code></pre></div><p>那么，接下来就可以按照我们之前学习的方式来使用Vue了</p>
<p>我们创建一个Vue实例：</p>
<div class="highlight" id="id-27"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">   <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#app&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;coderwhy&#39;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">})</span></span></span></code></pre></div><p>上面的Vue实例中，我们要挂载一个#app对应的元素，所以也要修改index.html</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/241.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/241.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/241.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/241.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/241.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/241.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>修改完成后，重新打包，运行程序：</p>
<ul>
<li>打包过程没有任何错误(因为只是多打包了一个vue的js文件而已)</li>
<li>但是运行程序，没有出现想要的效果，而且浏览器中有报错</li>
</ul>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/242.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/242.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/242.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/242.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/242.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/242.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>这个错误说的是我们使用的是runtime-only版本的Vue，什么意思呢？</p>
<ul>
<li>这个在后续的课程中我具体说明runtime-compiler和runtime-only的区别。</li>
<li>这里我只说解决方案：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Finstallation.html%23%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A"target="_blank" rel="external nofollow noopener noreferrer">Vue不同版本构建</a></li>
<li>所以我们修改webpack的配置，添加如下内容即可</li>
</ul>
<div class="highlight" id="id-28"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alias</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="s1">&#39;vue$&#39;</span><span class="o">:</span> <span class="s1">&#39;vue/dist/vue.esm.js&#39;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span></span></span></code></pre></div><p>重新打包，运行程序：</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/243.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/243.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/243.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/243.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/243.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/243.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h4 id="52-el和template">5.2. el和template</h4>
<p>正常运行之后，我们来考虑另外一个问题：</p>
<ul>
<li>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</li>
<li>如果我们后面自定义了组件，也必须修改index.html来使用组件</li>
<li>但是html模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？</li>
</ul>
<p>定义template属性：</p>
<ul>
<li>在前面的Vue实例中，我们已经定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容</li>
<li>这里，我们可以将div元素中的{{message}}内容删掉，只保留一个基本的id为div的元素</li>
<li>但是如果我依然希望在其中显示{{message}}的内容，应该怎么处理呢？</li>
<li>我们可以再定义一个template属性，代码如下：</li>
</ul>
<div class="highlight" id="id-29"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#app&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;div id=&#34;app&#34;&gt;{{message}}&lt;/div&gt;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;coderwhy&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span></span></span></code></pre></div><p>重新打包，运行程序，显示一样的结果和HTML代码结构</p>
<p>那么，el和template模板的关系是什么呢？</p>
<ul>
<li>在我们之前的学习中，我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等。</li>
<li>而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。</li>
</ul>
<p>这样做有什么好处呢？</p>
<ul>
<li>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可</li>
</ul>
<p>但是，书写template模块非常麻烦怎么办呢？</p>
<ul>
<li>没有关系，稍后我们会将template模板中的内容进行抽离。</li>
<li>会分成三部分书写：template、script、style，结构变得非常清晰。</li>
</ul>
<h4 id="53-vue组件化开发">5.3. Vue组件化开发</h4>
<p>在学习组件化开发的时候，我说过以后的Vue开发过程中，我们都会采用组件化开发的思想。</p>
<p>那么，在当前项目中，如果我也想采用组件化的形式进行开发，应该怎么做呢？</p>
<p>查看下面的代码：</p>
<ul>
<li>1.定义一个组件对象</li>
<li>2.在Vue实例的components中进行注册</li>
<li>3.在Vue实例的template模板中使用</li>
</ul>
<div class="highlight" id="id-30"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">App</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;h2&gt;{{name}}&lt;/h2&gt;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;我是APP组件&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#app&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">template</span><span class="o">:</span> <span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">    &lt;div id=&#34;app&#34;&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">      {{message}}
</span></span></span><span class="line"><span class="cl"><span class="sb">      &lt;App/&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">    &lt;/div&gt;`</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;coderwhy&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">App</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span></span></span></code></pre></div><p>重新打包，运行程序，组件内容正常的显示出来了。</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/244.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/244.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/244.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/244.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/244.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/244.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>为了方便维护我们的App组件，我们可以将对应的代码单独抽离取出</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/245.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/245.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/245.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/245.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/245.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/245.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>代码依然可以正常运行，没有问题。</p>
<h4 id="54-vue文件封装处理">5.4. .vue文件封装处理</h4>
<p>但是一个组件以一个js对象的形式进行组织和使用的时候是非常不方便的</p>
<ul>
<li>一方面编写template模块非常的麻烦</li>
<li>另外一方面如果有样式的话，我们写在哪里比较合适呢？</li>
</ul>
<p>现在，我们以一种全新的方式来组织一个vue的组件</p>
<div class="highlight" id="id-31"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;title&#34;</span><span class="p">&gt;</span>{{name}}<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;App&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;我是.vue的App组件&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">style</span> <span class="na">scoped</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nc">title</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">color</span><span class="p">:</span> <span class="kc">blue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span></span></span></code></pre></div><p>但是，这个时候这个文件可以被正确的加载吗？</p>
<ul>
<li>必然不可以，这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</li>
<li>谁来处理呢？vue-loader以及vue-template-compiler。</li>
</ul>
<p>安装vue-loader和vue-template-compiler</p>
<div class="highlight" id="id-32"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install vue-loader vue-template-compiler --save-dev</span></span></code></pre></div><p>修改webpack.config.js的配置文件：</p>
<div class="highlight" id="id-33"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.vue$/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">use</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;vue-loader&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>重新打包，运行程序，你会发现.vue文件已经可以被识别，并且正确的显示了出来。</p>
<h3 id="六-plugin的使用">六. plugin的使用</h3>
<h4 id="61-认识plugin">6.1. 认识plugin</h4>
<p>plugin是什么？</p>
<ul>
<li>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</li>
<li>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</li>
</ul>
<p>loader和plugin区别</p>
<ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li>
</ul>
<p>plugin的使用过程：</p>
<ul>
<li>步骤一：通过npm安装需要使用的plugins(某些内置插件不需要安装)</li>
<li>步骤二：在webpack.config.js中的plugins中配置插件。</li>
</ul>
<p>下面，我们就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让我们的webpack变得更加好用。</p>
<h4 id="62-添加版权的plugin">6.2. 添加版权的Plugin</h4>
<p>我们先来使用一个最简单的插件，为打包的文件添加版权声明</p>
<ul>
<li>该插件名字叫BannerPlugin，属于webpack自带的插件。</li>
</ul>
<p>按照下面的方式来修改webpack.config.js的文件：</p>
<div class="highlight" id="id-34"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;webpack&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">webpack</span><span class="p">.</span><span class="nx">BannerPlugin</span><span class="p">(</span><span class="s1">&#39;最终版权归coderwhy所有&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>重新打包程序：查看bundle.js文件的头部，看到如下信息</p>
<p><img loading="lazy" src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/246.png" srcset="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/246.png, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/246.png 1.5x, https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/246.png 2x" sizes="auto" data-title="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/246.png" data-alt="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/vue/246.png" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h4 id="63-打包html的plugin">6.3. 打包html的plugin</h4>
<p>目前，我们的index.html文件是存放在项目的根目录下的。</p>
<p>我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。</p>
<p>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件</p>
<p>HtmlWebpackPlugin插件可以为我们做这些事情：</p>
<ul>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ul>
<p>安装HtmlWebpackPlugin插件</p>
<div class="highlight" id="id-35"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install html-webpack-plugin --save-dev</span></span></code></pre></div><p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<div class="highlight" id="id-36"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">webpack</span><span class="p">.</span><span class="nx">BannerPlugin</span><span class="p">(</span><span class="s1">&#39;最终版权归coderwhy所有&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">htmlWebpackPlugin</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">      <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;index.html&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}),</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span></span></span></code></pre></div><p>注意：</p>
<ul>
<li>这里的template表示根据什么模板来生成index.html</li>
<li>另外，我们需要删除之前在output中添加的publicPath属性，否则插入的script标签中的src可能会有问题</li>
</ul>
<h4 id="63-js压缩的plugin">6.3. js压缩的plugin</h4>
<p>在项目发布之前，我们必然需要对js等文件进行压缩处理</p>
<p>这里，我们就对打包的js文件进行压缩</p>
<ul>
<li>我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致</li>
</ul>
<p>安装uglifyjs-webpack-plugin插件：</p>
<div class="highlight" id="id-37"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span></span></code></pre></div><p>修改webpack.config.js文件，使用插件：</p>
<div class="highlight" id="id-38"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;webpack&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">uglifyJsPlugin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;uglifyjs-webpack-plugin&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">webpack</span><span class="p">.</span><span class="nx">BannerPlugin</span><span class="p">(</span><span class="s1">&#39;最终版权归coderwhy所有&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">uglifyJsPlugin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>   
</span></span></code></pre></div><p>查看打包后的bunlde.js文件，是已经被压缩过了。</p>
<h3 id="七-搭建本地服务">七. 搭建本地服务</h3>
<blockquote>
<p>现在我们的环境有一个很大的弊端，每次修改了代码都需要手动来编译（当然可以通过watch），另外编译后要刷新页面才能看到对应的效果。</p>
<p>如果代码修改后，可以自动刷新浏览器看到修改后的效果，会大大提升我们的开发效率。</p>
</blockquote>
<h4 id="71-搭建本地服务">7.1. 搭建本地服务</h4>
<p>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</p>
<p>不过它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<div class="highlight" id="id-39"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">npm install --save-dev webpack-dev-server@2.9.1</span></span></code></pre></div><p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</p>
<ul>
<li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</li>
<li>port：端口号</li>
<li>inline：页面实时刷新</li>
<li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li>
</ul>
<p>webpack.config.js文件配置修改如下：</p>
<div class="highlight" id="id-40"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">  <span class="nx">devServer</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">contentBase</span><span class="o">:</span> <span class="s1">&#39;./dist&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">inline</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span></span></span></code></pre></div><p>另外，我们再针对开发环境在package.json中配置一个scripts</p>
<ul>
<li>&ndash;open参数表示直接打开浏览器</li>
</ul>
<div class="highlight" id="id-41"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;dev&#34;</span><span class="err">:</span> <span class="s2">&#34;webpack-dev-server --open&#34;</span></span></span></code></pre></div><p>通过npm run dev启动环境，就会发现我们已经有了一个可以实时刷新页面的本地服务了。</p>
<h4 id="72-模块热更新">7.2. 模块热更新</h4>
<p>搭建完本地服务后固然非常好用，但是它还是存在一个弊端：当只有一部分代码发生变化时，我们去刷新了整个页面。</p>
<p>很明显，如果我们能在修改完代码后只刷新修改的部分，那么界面的更新效率会更高。</p>
<ul>
<li>如何能做到呢？使用HotModuleReplacementPlugin插件即可。</li>
<li>该拆件是一个webpack内置的插件，并不需要安装，直接使用即可</li>
</ul>
<p>在webpack.config.js文件中修改插件如下：</p>
<div class="highlight" id="id-42"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="nx">devServer</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">contentBase</span><span class="o">:</span> <span class="s1">&#39;./dist&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">inline</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hot</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">webpack</span><span class="p">.</span><span class="nx">BannerPlugin</span><span class="p">(</span><span class="s1">&#39;最终版权归coderwhy所有&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">uglifyJsPlugin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">htmlWebpackPlugin</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">      <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;index.html&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}),</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">webpack</span><span class="p">.</span><span class="nx">HotModuleReplacementPlugin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 0001-01-01 00:00:00">更新于 0001-01-01&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://yuanshuai1122.github.com/posts/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" data-title="Vue之webpack深入解析" data-hashtags="Vue"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://yuanshuai1122.github.com/posts/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" data-hashtag="Vue"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://yuanshuai1122.github.com/posts/vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-vue%E4%B9%8Bwebpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" data-title="Vue之webpack深入解析"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/vue/' class="post-tag">Vue</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/vue%E4%B9%8B%E6%8F%92%E5%80%BC%E6%93%8D%E4%BD%9C-vue%E4%B9%8B%E6%8F%92%E5%80%BC%E6%93%8D%E4%BD%9C/" class="post-nav-item" rel="prev" title="Vue之插值操作"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>Vue之插值操作</a>
      <a href="/posts/vue%E4%B9%8Bvuex%E4%B8%80-vue%E4%B9%8Bvuex%E4%B8%80/" class="post-nav-item" rel="next" title="Vue之Vuex（一）">Vue之Vuex（一）<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.119.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.2.18-lts.2"><img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" />&nbsp;FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2023</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span></div><div class="footer-line statistics"></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
