<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JVM内存与垃圾回收篇第5章虚拟机栈 - 🧀 - 你好</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="yuanshuai" /><meta name="description" content="第 5 章 虚拟机栈 1、虚拟机栈概述 1.1、虚拟机栈的出现背景 文档网址 https://docs.oracle.com/javase/specs/jvms/se8/html/index.html 虚拟机栈出现的背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不" /><meta name="keywords" content="blog, yuanshuai, yyss" />






<meta name="generator" content="Hugo 0.119.0 with theme even" />


<link rel="canonical" href="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC5%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC5%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/yuanshuai1122.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/yuanshuai1122.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/yuanshuai1122.github.io/favicon-16x16.png">
<link rel="manifest" href="/yuanshuai1122.github.io/manifest.json">
<link rel="mask-icon" href="/yuanshuai1122.github.io/safari-pinned-tab.svg" color="#5bbad5">



<link href="/yuanshuai1122.github.io/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JVM内存与垃圾回收篇第5章虚拟机栈" />
<meta property="og:description" content="第 5 章 虚拟机栈 1、虚拟机栈概述 1.1、虚拟机栈的出现背景 文档网址 https://docs.oracle.com/javase/specs/jvms/se8/html/index.html 虚拟机栈出现的背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC5%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC5%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" /><meta property="article:section" content="post" />


<meta itemprop="name" content="JVM内存与垃圾回收篇第5章虚拟机栈">
<meta itemprop="description" content="第 5 章 虚拟机栈 1、虚拟机栈概述 1.1、虚拟机栈的出现背景 文档网址 https://docs.oracle.com/javase/specs/jvms/se8/html/index.html 虚拟机栈出现的背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不">

<meta itemprop="wordCount" content="13768">
<meta itemprop="keywords" content="Java,JVM," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM内存与垃圾回收篇第5章虚拟机栈"/>
<meta name="twitter:description" content="第 5 章 虚拟机栈 1、虚拟机栈概述 1.1、虚拟机栈的出现背景 文档网址 https://docs.oracle.com/javase/specs/jvms/se8/html/index.html 虚拟机栈出现的背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">CNshuaiyuan</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="yuanshuai1122.github.io/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="yuanshuai1122.github.io/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="yuanshuai1122.github.io/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="yuanshuai1122.github.io/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">CNshuaiyuan</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JVM内存与垃圾回收篇第5章虚拟机栈</h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
          <span class="more-meta"> 约 13768 字 </span>
          <span class="more-meta"> 预计阅读 28 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第-5-章-虚拟机栈">第 5 章 虚拟机栈</a>
      <ul>
        <li><a href="#1虚拟机栈概述">1、虚拟机栈概述</a>
          <ul>
            <li><a href="#11虚拟机栈的出现背景">1.1、虚拟机栈的出现背景</a></li>
            <li><a href="#12虚拟机栈的存储内容">1.2、虚拟机栈的存储内容</a></li>
            <li><a href="#13虚拟机栈的特点">1.3、虚拟机栈的特点</a></li>
            <li><a href="#14虚拟机栈的异常">1.4、虚拟机栈的异常</a></li>
            <li><a href="#15设置栈内存大小">1.5、设置栈内存大小</a></li>
          </ul>
        </li>
        <li><a href="#2栈的存储单位">2、栈的存储单位</a>
          <ul>
            <li><a href="#21栈的运行原理">2.1、栈的运行原理</a></li>
            <li><a href="#22栈的内部结构">2.2、栈的内部结构</a></li>
          </ul>
        </li>
        <li><a href="#3局部变量表">3、局部变量表</a>
          <ul>
            <li><a href="#31认识局部变量表">3.1、认识局部变量表</a></li>
            <li><a href="#32关于-slot-的理解">3.2、关于 Slot 的理解</a></li>
            <li><a href="#33slot-的重复利用">3.3、Slot 的重复利用</a></li>
          </ul>
        </li>
        <li><a href="#4操作数栈">4、操作数栈</a>
          <ul>
            <li><a href="#41操作数栈的特点">4.1、操作数栈的特点</a></li>
            <li><a href="#42操作数栈的作用">4.2、操作数栈的作用</a></li>
          </ul>
        </li>
        <li><a href="#5代码追踪">5、代码追踪</a></li>
        <li><a href="#6栈顶缓存技术">6、栈顶缓存技术</a></li>
        <li><a href="#7动态链接">7、动态链接</a></li>
        <li><a href="#8解析和分派">8、解析和分派</a>
          <ul>
            <li><a href="#81静态链接与动态链接">8.1、静态链接与动态链接</a></li>
            <li><a href="#82早期绑定与晚期绑定">8.2、早期绑定与晚期绑定</a></li>
            <li><a href="#83多态性与方法绑定">8.3、多态性与方法绑定</a></li>
            <li><a href="#84方法重写的本质">8.4、方法重写的本质</a></li>
            <li><a href="#85多态与虚方法表">8.5、多态与虚方法表</a></li>
          </ul>
        </li>
        <li><a href="#9方法返回地址">9、方法返回地址</a></li>
        <li><a href="#10一些附加信息">10、一些附加信息</a></li>
        <li><a href="#11栈相关面试题">11、栈相关面试题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="0001-01-01T00:00:00" title="January 1, 0001">January 1, 0001</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <h1 id="第-5-章-虚拟机栈">第 5 章 虚拟机栈</h1>
<h2 id="1虚拟机栈概述">1、虚拟机栈概述</h2>
<h3 id="11虚拟机栈的出现背景">1.1、虚拟机栈的出现背景</h3>
<blockquote>
<p><strong>文档网址</strong></p>
</blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<blockquote>
<p><strong>虚拟机栈出现的背景</strong></p>
</blockquote>
<ol>
<li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。</li>
<li><strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</strong>。</li>
</ol>
<blockquote>
<p><strong>内存中的栈与堆</strong></p>
</blockquote>
<p><strong>首先栈是运行时的单位，而堆是存储的单位</strong></p>
<ol>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/59.png" alt=""></p>
<h3 id="12虚拟机栈的存储内容">1.2、虚拟机栈的存储内容</h3>
<blockquote>
<p><strong>虚拟机栈的基本内容</strong></p>
</blockquote>
<p><strong>Java虚拟机栈是什么</strong>？</p>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p>
<hr>
<p><strong>虚拟机栈的生命周期</strong></p>
<p><strong>生命周期和线程一致</strong>，也就是线程结束了，该虚拟机栈也销毁了</p>
<hr>
<p><strong>虚拟机栈的作用</strong></p>
<p><strong>主管Java程序的运行</strong>，它<strong>保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</strong>。</p>
<ol>
<li>局部变量，它是相比于成员变量来说的（或属性）</li>
<li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li>
</ol>
<h3 id="13虚拟机栈的特点">1.3、虚拟机栈的特点</h3>
<blockquote>
<p><strong>栈的特点</strong></p>
</blockquote>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p>
<ol>
<li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li>
<li>执行结束后的<strong>出栈</strong>工作</li>
</ol>
<hr>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/60.png" alt=""></p>
<h3 id="14虚拟机栈的异常">1.4、虚拟机栈的异常</h3>
<blockquote>
<p><strong>栈中可能出现的异常</strong></p>
</blockquote>
<p>面试题：栈中可能出现的异常</p>
<ol>
<li>Java 虚拟机规范允许Java栈的大小<strong>是动态的或者是固定不变的</strong>。</li>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。</li>
<li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</li>
</ol>
<blockquote>
<p><strong>栈异常演示</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackErrorTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>递归调用 11418 次后，出现栈内存溢出</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/61.png" alt=""></p>
<h3 id="15设置栈内存大小">1.5、设置栈内存大小</h3>
<blockquote>
<p><strong>设置栈内存的大小</strong></p>
</blockquote>
<ul>
<li>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-Xss1024m		// 栈内存为 1024MBS
</span></span><span class="line"><span class="cl">-Xss1024k		// 栈内存为 1024KB
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>设置线程的最大栈空间：256KB</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/62.png" alt=""></p>
<ul>
<li>代码测试</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackErrorTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>递归 2471 次，栈内存溢出</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/63.png" alt=""></p>
<h2 id="2栈的存储单位">2、栈的存储单位</h2>
<h3 id="21栈的运行原理">2.1、栈的运行原理</h3>
<blockquote>
<p><strong>栈存储什么？</strong></p>
</blockquote>
<ol>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li>
<li>在这个线程上<strong>正在执行的每个方法都各自对应一个栈帧（Stack Frame）</strong>。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着<strong>方法执行</strong>过程中的各种数据信息。</li>
</ol>
<blockquote>
<p><strong>栈的运行原理</strong></p>
</blockquote>
<ol>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即<strong>只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的</strong>
<ul>
<li>这个栈帧被称为<strong>当前栈帧（Current Frame）</strong></li>
<li>与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong></li>
<li>定义这个方法的类就是<strong>当前类（Current Class）</strong></li>
</ul>
</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，<strong>方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧</strong>，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式，但不管使用哪种方式，都会导致栈帧被弹出
<ul>
<li>一种是<strong>正常的函数返回</strong>，使用return指令</li>
<li>另外一种是<strong>抛出异常</strong></li>
</ul>
</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/64.png" alt=""></p>
<p><strong>代码示例：</strong></p>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackFrameTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">StackFrameTest</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StackFrameTest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span><span class="o">.</span><span class="na">method1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;method1()开始执行...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">method2</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;method1()执行结束...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">method2</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;method2()开始执行...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">method3</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;method2()即将结束...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">method3</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;method3()开始执行...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">20</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;method3()即将结束...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>先执行的函数，最后执行结束</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">method1()开始执行...
</span></span><span class="line"><span class="cl">method2()开始执行...
</span></span><span class="line"><span class="cl">method3()开始执行...
</span></span><span class="line"><span class="cl">method3()即将结束...
</span></span><span class="line"><span class="cl">method2()即将结束...
</span></span><span class="line"><span class="cl">method1()执行结束...
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>反编译，可以看到每个方法后面都带有 return 语句或者 ireturn 语句</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  public void method1();
</span></span><span class="line"><span class="cl">    descriptor: ()V
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=2, locals=1, args_size=1
</span></span><span class="line"><span class="cl">         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">         3: ldc           #6                  // String method1()开始执行...
</span></span><span class="line"><span class="cl">         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">         8: aload_0
</span></span><span class="line"><span class="cl">         9: invokevirtual #8                  // Method method2:()I
</span></span><span class="line"><span class="cl">        12: pop
</span></span><span class="line"><span class="cl">        13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">        16: ldc           #9                  // String method1()执行结束...
</span></span><span class="line"><span class="cl">        18: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">        21: return
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 16: 0
</span></span><span class="line"><span class="cl">        line 17: 8
</span></span><span class="line"><span class="cl">        line 18: 13
</span></span><span class="line"><span class="cl">        line 19: 21
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0      22     0  this   Lcom/atguigu/java1/StackFrameTest;
</span></span><span class="line"><span class="cl">1234567891011121314151617181920212223
</span></span><span class="line"><span class="cl">  public int method2();
</span></span><span class="line"><span class="cl">    descriptor: ()I
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=2, locals=3, args_size=1
</span></span><span class="line"><span class="cl">         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">         3: ldc           #10                 // String method2()开始执行...
</span></span><span class="line"><span class="cl">         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">         8: bipush        10
</span></span><span class="line"><span class="cl">        10: istore_1
</span></span><span class="line"><span class="cl">        11: aload_0
</span></span><span class="line"><span class="cl">        12: invokevirtual #11                 // Method method3:()D
</span></span><span class="line"><span class="cl">        15: d2i
</span></span><span class="line"><span class="cl">        16: istore_2
</span></span><span class="line"><span class="cl">        17: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">        20: ldc           #12                 // String method2()即将结束...
</span></span><span class="line"><span class="cl">        22: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">        25: iload_1
</span></span><span class="line"><span class="cl">        26: iload_2
</span></span><span class="line"><span class="cl">        27: iadd
</span></span><span class="line"><span class="cl">        28: ireturn
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 22: 0
</span></span><span class="line"><span class="cl">        line 23: 8
</span></span><span class="line"><span class="cl">        line 24: 11
</span></span><span class="line"><span class="cl">        line 25: 17
</span></span><span class="line"><span class="cl">        line 26: 25
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0      29     0  this   Lcom/atguigu/java1/StackFrameTest;
</span></span><span class="line"><span class="cl">           11      18     1     i   I
</span></span><span class="line"><span class="cl">           17      12     2     m   I
</span></span><span class="line"><span class="cl">           
</span></span><span class="line"><span class="cl">  public double method3();
</span></span><span class="line"><span class="cl">    descriptor: ()D
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=2, locals=3, args_size=1
</span></span><span class="line"><span class="cl">         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">         3: ldc           #13                 // String method3()开始执行...
</span></span><span class="line"><span class="cl">         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">         8: ldc2_w        #14                 // double 20.0d
</span></span><span class="line"><span class="cl">        11: dstore_1
</span></span><span class="line"><span class="cl">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">        15: ldc           #16                 // String method3()即将结束...
</span></span><span class="line"><span class="cl">        17: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">        20: dload_1
</span></span><span class="line"><span class="cl">        21: dreturn
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 30: 0
</span></span><span class="line"><span class="cl">        line 31: 8
</span></span><span class="line"><span class="cl">        line 32: 12
</span></span><span class="line"><span class="cl">        line 33: 20
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0      22     0  this   Lcom/atguigu/java1/StackFrameTest;
</span></span><span class="line"><span class="cl">           12      10     1     j   D
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="22栈的内部结构">2.2、栈的内部结构</h3>
<blockquote>
<p><strong>栈帧内部结构</strong></p>
</blockquote>
<p><strong>每个栈帧中存储着：</strong></p>
<ol>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/65.png" alt=""></p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/66.png" alt=""></p>
<h2 id="3局部变量表">3、局部变量表</h2>
<h3 id="31认识局部变量表">3.1、认识局部变量表</h3>
<blockquote>
<p><strong>认识局部变量表</strong></p>
</blockquote>
<ol>
<li>
<p>局部变量表：<strong>Local Variables，被称之为局部变量数组或本地变量表</strong></p>
</li>
<li>
<p>定义为一个<strong>数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p>
</li>
<li>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p>
</li>
<li>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
</li>
<li>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</p>
<ul>
<li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li>
<li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
</ul>
</li>
<li>
<p>局部变量表中的变量只在当前方法调用中有效。</p>
<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocalVariablesTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LocalVariablesTest</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LocalVariablesTest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span><span class="o">.</span><span class="na">test1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">name1</span> <span class="o">=</span> <span class="s">&#34;atguigu.com&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">test2</span><span class="o">(</span><span class="n">date</span><span class="o">,</span> <span class="n">name1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">date</span> <span class="o">+</span> <span class="n">name1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">test2</span><span class="o">(</span><span class="n">Date</span> <span class="n">dateP</span><span class="o">,</span> <span class="n">String</span> <span class="n">name2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dateP</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">name2</span> <span class="o">=</span> <span class="s">&#34;songhongkang&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="mi">130</span><span class="o">.</span><span class="na">5</span><span class="o">;</span><span class="c1">//占据两个slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="n">gender</span> <span class="o">=</span> <span class="sc">&#39;男&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dateP</span> <span class="o">+</span> <span class="n">name2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>反编译后，可得结论：</p>
<ul>
<li><strong>在编译期间，局部变量的个数、每个局部变量的大小都已经被记录下来</strong></li>
<li>所以局部变量表所需的容量大小是在编译期确定下来的</li>
</ul>
</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/67.png" alt=""></p>
<ul>
<li>利用 JClassLib 也可以查看局部变量的个数</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/68.png" alt=""></p>
<p><strong>思考：</strong></p>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="o">(</span><span class="n">args</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">LocalVariablesTest</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LocalVariablesTest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>反编译后，提出问题：上面代码中的 test 变量跑哪儿哪了呢？</li>
<li>我估计 test 变量和 num 变量共用一个 slot</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/69.png" alt=""></p>
<blockquote>
<p><strong>字节码中方法内部结构的剖析</strong></p>
</blockquote>
<ul>
<li>
<p>[Ljava/lang/String] ：</p>
<ul>
<li>[] 表示数组</li>
<li>L 表示引用类型</li>
<li>java/lang/String 表示 java.lang.String</li>
</ul>
</li>
<li>
<p>合起来就是：main() 方法的形参类型为 String[]</p>
</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/70.png" alt=""></p>
<ul>
<li>字节码，字节码长度为 16（0~15）</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/71.png" alt=""></p>
<ul>
<li>方法异常信息表</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/72.png" alt=""></p>
<ul>
<li>杂项（Misc）</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/73.png" alt=""></p>
<ul>
<li>字节码指令行号和原始 java 代码行号的对应关系</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/74.png" alt=""></p>
<ul>
<li>注意：生效行数和剩余有效行数都是针对于字节码文件的行数</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/75.png" alt=""></p>
<h3 id="32关于-slot-的理解">3.2、关于 Slot 的理解</h3>
<blockquote>
<p><strong>关于 Slot 的理解</strong></p>
</blockquote>
<ol>
<li>参数值的存放总是<strong>从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束</strong>。</li>
<li><strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>
<li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。</li>
<li><strong>JVM会为局部变量表中的每一个Slot都分配一个访问索引</strong>，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序</strong>被复制到局部变量表中的每一个slot上</li>
<li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或doub1e类型变量）</li>
<li>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/76.png" alt=""></p>
<blockquote>
<p><strong>Slot 代码示例</strong></p>
</blockquote>
<p><strong>this 存放在 index = 0 的位置：</strong></p>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">test3</span><span class="o">()</span> <span class="o">{</span>    <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">++;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>局部变量表：this 存放在 index = 0 的位置</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/77.png" alt=""></p>
<p><strong>64位的类型（1ong和double）占用两个slot</strong></p>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">String</span> <span class="nf">test2</span><span class="o">(</span><span class="n">Date</span> <span class="n">dateP</span><span class="o">,</span> <span class="n">String</span> <span class="n">name2</span><span class="o">)</span> <span class="o">{</span>    <span class="n">dateP</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>    <span class="n">name2</span> <span class="o">=</span> <span class="s">&#34;songhongkang&#34;</span><span class="o">;</span>    <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="mi">130</span><span class="o">.</span><span class="na">5</span><span class="o">;</span><span class="c1">//占据两个slot    char gender = &#39;男&#39;;    return dateP + name2;}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>weight 为 double 类型，index 直接从 3 蹦到了 5</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/78.png" alt=""></p>
<p><strong>static 无法调用 this</strong></p>
<ul>
<li>this 不存在与 static 方法的局部变量表中，所以无法调用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//练习：public static void testStatic(){    LocalVariablesTest test = new LocalVariablesTest();    Date date = new Date();    int count = 10;    System.out.println(count);    //因为 this 变量不存在于当前方法的局部变量表中！！    //System.out.println(this.count);}
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="33slot-的重复利用">3.3、Slot 的重复利用</h3>
<blockquote>
<p><strong>Slot 的重复利用</strong></p>
</blockquote>
<p>栈帧中的局部变量表中的槽位是<strong>可以重用</strong>的，<strong>如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位</strong>，从而达到节省资源的目的。</p>
<hr>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">test4</span><span class="o">()</span> <span class="o">{</span>    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="o">{</span>        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>    <span class="o">}</span>    <span class="c1">//变量c使用之前已经销毁的变量b占据的slot的位置    int c = a + 1;}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>局部变量 c 重用了局部变量 b 的 slot 位置</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/79.png" alt=""></p>
<blockquote>
<p><strong>静态变量与局部变量的对比</strong></p>
</blockquote>
<p><strong>变量的分类：</strong></p>
<ol>
<li>
<p>按照数据类型分：</p>
<ol>
<li>基本数据类型</li>
</ol>
</li>
<li>
<p>引用数据类型</p>
</li>
<li>
<p>按照在类中声明的方式分：</p>
<ol>
<li>
<p>成员变量</p>
<ol>
<li>类变量：在linking的prepare阶段给类变量默认赋值；在initial阶段给类变量显式赋值即静态代码块赋值</li>
</ol>
</li>
</ol>
</li>
<li>
<p>实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</p>
</li>
<li>
<p>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过，应该是栈中数据弹出后，不会清除上次的值，再次使用时，如果不显示初始化，就会出现脏数据</p>
</li>
</ol>
<hr>
<ol>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li>
<li>我们知道<strong>类变量表有两次初始化的机会</strong>，<strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值</strong>。</li>
<li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ol>
<hr>
<p><strong>代码示例</strong></p>
<ul>
<li>报错：局部变量未初始化</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/80.png" alt=""></p>
<blockquote>
<p><strong>补充说明</strong></p>
</blockquote>
<ol>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点</strong>，只要被局部变量表中直接或间接引用的对象都不会被回收。</li>
</ol>
<h2 id="4操作数栈">4、操作数栈</h2>
<h3 id="41操作数栈的特点">4.1、操作数栈的特点</h3>
<blockquote>
<p><strong>操作数栈的特点</strong></p>
</blockquote>
<p><strong>操作数栈：Operand Stack</strong></p>
<ol>
<li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li>
<li>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</li>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，比如：执行复制、交换、求和等操作</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/81.png" alt=""></p>
<p><strong>代码举例</strong></p>
<ul>
<li>左边为 java 源代码，右边为 java 代码编译生成的字节码指令</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/82.png" alt=""></p>
<h3 id="42操作数栈的作用">4.2、操作数栈的作用</h3>
<blockquote>
<p><strong>操作数栈的作用</strong></p>
</blockquote>
<ol>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的（这个时候数组是有长度的，只是操作数栈为空）</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的<strong>最大深度在编译期就定义好了</strong>，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是<strong>只能通过标准的入栈和出栈操作来完成一次数据访问</strong></li>
<li>如果被调用的方法带有返回值的话，其<strong>返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
<li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li>
</ol>
<blockquote>
<p><strong>操作数栈的深度</strong></p>
</blockquote>
<p>通过反编译生成的字节码指令查看操作数栈的深度</p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/83.png" alt=""></p>
<h2 id="5代码追踪">5、代码追踪</h2>
<blockquote>
<p><strong>操作数栈代码追踪</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testAddOperation</span><span class="o">()</span> <span class="o">{</span>    <span class="c1">//byte、short、char、boolean：都以int型来保存    byte i = 15;    int j = 8;    int k = i + j;}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>反编译得到的字节码指令</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> 0 bipush 15 2 istore_1 3 bipush 8 5 istore_2 6 iload_1 7 iload_2 8 iadd 9 istore_310 return
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>程序执行流程如下</strong></p>
<ul>
<li>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/84.png" alt=""></p>
<ul>
<li>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</li>
<li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/85.png" alt=""></p>
<ul>
<li>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/86.png" alt=""></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/87.png" alt=""></p>
<ul>
<li>然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/88.png" alt=""></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/89.png" alt=""></p>
<ul>
<li>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/90.png" alt=""></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/91.png" alt=""></p>
<blockquote>
<p><strong>关于 int j = 8; 的说明</strong></p>
</blockquote>
<ul>
<li>
<p>我们反编译得到的字节码指令如下</p>
<ul>
<li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li>
<li>然后执行将数值 8 存放在 int 类型的变量中：istore_2</li>
</ul>
</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/92.png" alt=""></p>
<blockquote>
<p><strong>关于调用方法，返回值入操作数栈的说明</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(){</span>    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>    <span class="k">return</span> <span class="n">k</span><span class="o">;}</span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetSum</span><span class="o">(){</span>    <span class="c1">//获取上一个栈桢返回的结果，并保存在操作数栈中    int i = getSum();    int j = 10;}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>getSum() 方法字节码指令：最后带着个 ireturn</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/93.png" alt=""></p>
<ul>
<li>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/94.png" alt=""></p>
<blockquote>
<p><strong>++i 与 i++ 的区别</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 程序员面试过程中， 常见的i++和++i 的区别，放到字节码篇章时再介绍。public void add(){    //第1类问题：    int i1 = 10;    i1++;    int i2 = 10;    ++i2;    //第2类问题：    int i3 = 10;    int i4 = i3++;    int i5 = 10;    int i6 = ++i5;    //第3类问题：    int i7 = 10;    i7 = i7++;    int i8 = 10;    i8 = ++i8;    //第4类问题：    int i9 = 10;    int i10 = i9++ + ++i9;}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>下面，我根据字节码指令，简单说下 i++ 和 ++i 的区别</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> 0 bipush 10 2 istore_1 3 iinc 1 by 1 6 bipush 10 8 istore_2 9 iinc 2 by 112 bipush 1014 istore_315 iload_316 iinc 3 by 119 istore 421 bipush 1023 istore 525 iinc 5 by 128 iload 530 istore 632 bipush 1034 istore 736 iload 738 iinc 7 by 141 istore 743 bipush 1045 istore 847 iinc 8 by 150 iload 852 istore 854 bipush 1056 istore 958 iload 960 iinc 9 by 163 iinc 9 by 166 iload 968 iadd69 istore 1071 return
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>i++</strong></p>
<ul>
<li>java 源代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//第2类问题：int i3 = 10;int i4 = i3++;
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>字节码指令：</p>
<ul>
<li>bipush 10 ：将 10 压入操作数栈</li>
<li>istore_3 ：将操作数栈中的 10 保存到变量 i3 中</li>
<li>iload_3 ：将变量 i3 的值（10）加载至操作数栈中</li>
<li>iinc 3 by 1：变量 i3 执行 +1 操作</li>
<li>istore 4：将操作数栈中的值保存至变量 i4 中（10）</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">12 bipush 1014 istore_315 iload_316 iinc 3 by 119 istore 4
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>++i</strong></p>
<ul>
<li>java 源代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i5</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span><span class="kt">int</span> <span class="n">i6</span> <span class="o">=</span> <span class="o">++</span><span class="n">i5</span><span class="o">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>字节码指令</p>
<ul>
<li>bipush 10 ：将 10 压入操作数栈</li>
<li>istore 5 ：将操作数栈中的 10 保存到变量 i5 中</li>
<li>iinc 5 by 1：变量 i5 执行 +1 操作</li>
<li>iload 5 ：将变量 i5 的值（11）加载至操作数栈中</li>
<li>istore 6：将操作数栈中的值保存至变量 i6 中（11）</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">21 bipush 1023 istore 525 iinc 5 by 128 iload 530 istore 6
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>总结：</strong></p>
<ol>
<li>i++：先将 i 的值加载到操作数栈，再将 i 的值加 1</li>
<li>++i：先将 i 的值加 1，在将 i 的值加载到操作数栈</li>
</ol>
<blockquote>
<p><strong>注：以下是网友总结 ++i 与 i++ 的区别，我觉得不错，就加进来啦~~~</strong></p>
</blockquote>
<p><strong>i++</strong></p>
<ol>
<li>
<p>Java 代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">test1</span><span class="o">(){</span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">++;</span>    <span class="k">return</span> <span class="n">j</span><span class="o">;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>i++ 字节码详解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0 bipush 1    # 1 进栈2 istore_0    # 将栈顶元素弹出，赋值给索引为 0 的局部变量，也就是 i 变量（静态方法没有 this）3 iload_0	  # 将索引为 0 的局部变量（变量 i）压入栈4 iinc 0 by 1 # 索引为 0 的局部变量对应的数值加 1，所以此刻局部变量表索引 0 的值为 2，也就是 i = 27 istore_1    # 将栈顶元素 1 出栈，存入索引为 1 的局部变量中，因此此时 j = 1 8 iload_1	  # 将索引为 1 的局部变量压入栈，此时栈顶元素的值为 19 ireturn	  # 将栈顶元素 1 返回
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>++i</strong></p>
<ol>
<li>
<p>Java 代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">test1</span><span class="o">(){</span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span><span class="o">;</span>    <span class="k">return</span> <span class="n">j</span><span class="o">;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>++i字节码详解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0 bipush 1     # 1 进栈2 istore_0     # 将栈顶元素弹出，赋值给索引为 0 的局部变量，也就是 i 变量（静态方法没有 this）3 iinc 0 by 1  # 索引为 0 的局部变量对应的数值加 1，所以此刻局部变量表索引 0 的值为 2，也就是 i = 26 iload_0      # 将索引为 0 的局部变量（变量 i）压入栈7 istore_1     # 将栈顶元素 1 出栈，存入索引为 1 的局部变量中，因此此时 j = 2 8 iload_1      # 将索引为 1 的局部变量压入栈，此时栈顶元素的值为 29 ireturn      # 将栈顶元素 2 返回
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="6栈顶缓存技术">6、栈顶缓存技术</h2>
<blockquote>
<p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p>
</blockquote>
<ol>
<li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</li>
<li>寄存器的主要优点：指令更少，执行速度快</li>
</ol>
<h2 id="7动态链接">7、动态链接</h2>
<blockquote>
<p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p>
</blockquote>
<p><strong>动态链接：Dynamic Linking</strong></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/95.png" alt=""></p>
<ol>
<li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong></li>
<li>包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里</strong></li>
<li>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/96.png" alt=""></p>
<blockquote>
<p><strong>代码示例</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DynamicLinkingTest</span> <span class="o">{</span>    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodA</span><span class="o">(){</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;methodA()....&#34;</span><span class="o">);</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodB</span><span class="o">(){</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;methodB()....&#34;</span><span class="o">);</span>        <span class="n">methodA</span><span class="o">();</span>        <span class="n">num</span><span class="o">++;</span>    <span class="o">}}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A</li>
<li>那么 #7 是个啥呢？</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  public void methodB();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #6                  // String methodB()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: aload_0         9: invokevirtual #7                  // Method methodA:()V        12: aload_0        13: dup        14: getfield      #2                  // Field num:I        17: iconst_1        18: iadd        19: putfield      #2                  // Field num:I        22: return      LineNumberTable:        line 16: 0        line 18: 8        line 20: 12        line 21: 22      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      23     0  this   Lcom/atguigu/java1/DynamicLinkingTest;
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>往上面翻，找到常量池的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#7 = Methodref #8.#31
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>先找 #8 ：</p>
<ul>
<li><code>#8 = Class #32</code> ：去找 #32</li>
<li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li>
<li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li>
</ul>
</li>
<li>
<p>再来找 #31：</p>
<ul>
<li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li>
<li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li>
<li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li>
</ul>
</li>
</ul>
</li>
<li>
<p>结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Constant pool:   #1 = Methodref          #9.#23         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;   #4 = String             #27            // methodA()....   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V   #6 = String             #30            // methodB()....   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest   #9 = Class              #33            // java/lang/Object  #10 = Utf8               num  #11 = Utf8               I  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               LocalVariableTable  #17 = Utf8               this  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;  #19 = Utf8               methodA  #20 = Utf8               methodB  #21 = Utf8               SourceFile  #22 = Utf8               DynamicLinkingTest.java  #23 = NameAndType        #12:#13        // &#34;&lt;init&gt;&#34;:()V  #24 = NameAndType        #10:#11        // num:I  #25 = Class              #34            // java/lang/System  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;  #27 = Utf8               methodA()....  #28 = Class              #37            // java/io/PrintStream  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V  #30 = Utf8               methodB()....  #31 = NameAndType        #19:#13        // methodA:()V  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest  #33 = Utf8               java/lang/Object  #34 = Utf8               java/lang/System  #35 = Utf8               out  #36 = Utf8               Ljava/io/PrintStream;  #37 = Utf8               java/io/PrintStream  #38 = Utf8               println  #39 = Utf8               (Ljava/lang/String;)V
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</li>
</ul>
<blockquote>
<p><strong>为什么要用常量池呢？</strong></p>
</blockquote>
<ol>
<li>因为在不同的方法，都可能调用常量或者方法，所以<strong>只需要存储一份即可，然后记录其引用即可，节省了空间</strong></li>
<li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>
</ol>
<h2 id="8解析和分派">8、解析和分派</h2>
<h3 id="81静态链接与动态链接">8.1、静态链接与动态链接</h3>
<blockquote>
<p><strong>静态链接机制与动态链接机制</strong></p>
</blockquote>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ol>
<li>
<p><strong>静态链接</strong>：</p>
<p>当一个字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期确定，且运行期保持不变时</strong>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
</li>
<li>
<p><strong>动态链接</strong>：</p>
<p><strong>如果被调用的方法在编译期无法被确定下来</strong>，也就是说，<strong>只能够在程序运行期将调用的方法的符号转换为直接引用</strong>，由于这种引用转换过程具备<strong>动态性</strong>，因此也被称之为动态链接。</p>
</li>
</ol>
<h3 id="82早期绑定与晚期绑定">8.2、早期绑定与晚期绑定</h3>
<blockquote>
<p><strong>方法的绑定机制</strong></p>
</blockquote>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p>
<ol>
<li>
<p><strong>早期绑定</strong></p>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p>
</li>
<li>
<p><strong>晚期绑定</strong></p>
<p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ol>
<blockquote>
<p><strong>代码示例</strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/** * 说明早期绑定和晚期绑定的例子 * * @author shkstart * @create 2020 上午 11:59 */</span><span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;动物进食&#34;</span><span class="o">);</span>    <span class="o">}}</span><span class="kd">interface</span> <span class="nc">Huntable</span> <span class="o">{</span>    <span class="kt">void</span> <span class="nf">hunt</span><span class="o">();}</span><span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="kd">implements</span> <span class="n">Huntable</span> <span class="o">{</span>    <span class="nd">@Override</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;狗吃骨头&#34;</span><span class="o">);</span>    <span class="o">}</span>    <span class="nd">@Override</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hunt</span><span class="o">()</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;捕食耗子，多管闲事&#34;</span><span class="o">);</span>    <span class="o">}}</span><span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="kd">implements</span> <span class="n">Huntable</span> <span class="o">{</span>    <span class="kd">public</span> <span class="nf">Cat</span><span class="o">()</span> <span class="o">{</span>        <span class="kd">super</span><span class="o">();</span><span class="c1">//表现为：早期绑定    }    public Cat(String name) {        this();//表现为：早期绑定    }    @Override    public void eat() {        super.eat();//表现为：早期绑定        System.out.println(&#34;猫吃鱼&#34;);    }    @Override    public void hunt() {        System.out.println(&#34;捕食耗子，天经地义&#34;);    }}public class AnimalTest {    public void showAnimal(Animal animal) {        animal.eat();//表现为：晚期绑定    }    public void showHunt(Huntable h) {        h.hunt();//表现为：晚期绑定    }}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>invokevirtual 体现为晚期绑定</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/97.png" alt=""></p>
<ul>
<li>invokeinterface 也体现为晚期绑定</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/98.png" alt=""></p>
<ul>
<li>invokespecial 体现为早期绑定</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/99.png" alt=""></p>
<h3 id="83多态性与方法绑定">8.3、多态性与方法绑定</h3>
<blockquote>
<p><strong>多态性与方法绑定机制</strong></p>
</blockquote>
<ol>
<li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li>
<li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ol>
<blockquote>
<p><strong>虚方法与非虚方法</strong></p>
</blockquote>
<p><strong>虚方法与非虚方法的区别</strong></p>
<ol>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ol>
<p><strong>子类对象的多态的使用前提：</strong></p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<blockquote>
<p><strong>虚拟机中调用方法的指令</strong></p>
</blockquote>
<p><strong>四条普通指令：</strong></p>
<ol>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
<hr>
<p><strong>一条动态调用指令</strong></p>
<p>invokedynamic：动态解析出需要调用的方法，然后执行</p>
<hr>
<p><strong>区别</strong></p>
<ol>
<li>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预</li>
<li>而invokedynamic指令则支持由用户确定方法版本</li>
<li>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</li>
</ol>
<hr>
<p><strong>代码示例：</strong></p>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/** * 解析调用中非虚方法、虚方法的测试 * * invokestatic指令和invokespecial指令调用的方法称为非虚方法 * @author shkstart * @create 2020 下午 12:07 */</span><span class="kd">class</span> <span class="nc">Father</span> <span class="o">{</span>    <span class="kd">public</span> <span class="nf">Father</span><span class="o">()</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;father的构造器&#34;</span><span class="o">);</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">showStatic</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;father &#34;</span> <span class="o">+</span> <span class="n">str</span><span class="o">);</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">showFinal</span><span class="o">()</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;father show final&#34;</span><span class="o">);</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showCommon</span><span class="o">()</span> <span class="o">{</span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;father 普通方法&#34;</span><span class="o">);</span>    <span class="o">}}</span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span> <span class="o">{</span>    <span class="kd">public</span> <span class="nf">Son</span><span class="o">()</span> <span class="o">{</span>        <span class="c1">//invokespecial        super();    }    public Son(int age) {        //invokespecial        this();    }    //不是重写的父类的静态方法，因为静态方法不能被重写！    public static void showStatic(String str) {        System.out.println(&#34;son &#34; + str);    }    private void showPrivate(String str) {        System.out.println(&#34;son private&#34; + str);    }    public void show() {        //invokestatic        showStatic(&#34;atguigu.com&#34;);        //invokestatic        super.showStatic(&#34;good!&#34;);        //invokespecial        showPrivate(&#34;hello!&#34;);        //invokevirtual        //虽然字节码指令中显示为invokevirtual，但因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。        showFinal();        //invokespecial        super.showCommon();        //invokevirtual        //有可能子类会重写父类的showCommon()方法        showCommon();        info();        MethodInterface in = null;        //invokeinterface        in.methodA();    }    public void info() {    }    public void display(Father f) {        f.showCommon();    }    public static void main(String[] args) {        Son so = new Son();        so.show();    }}interface MethodInterface {    void methodA();}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Son 类中 show() 方法的字节码指令如下</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/100.png" alt=""></p>
<blockquote>
<p><strong>关于 invokedynamic 指令</strong></p>
</blockquote>
<ol>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ol>
<hr>
<p><strong>代码示例</strong></p>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterfaceinterface</span> <span class="n">Func</span> <span class="o">{</span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">func</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">);}</span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lambda</span> <span class="o">{</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lambda</span><span class="o">(</span><span class="n">Func</span> <span class="n">func</span><span class="o">)</span> <span class="o">{</span>        <span class="k">return</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>        <span class="n">Lambda</span> <span class="n">lambda</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Lambda</span><span class="o">();</span>        <span class="n">Func</span> <span class="n">func</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>        <span class="o">};</span>        <span class="n">lambda</span><span class="o">.</span><span class="na">lambda</span><span class="o">(</span><span class="n">func</span><span class="o">);</span>        <span class="n">lambda</span><span class="o">.</span><span class="na">lambda</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>        <span class="o">});</span>    <span class="o">}}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>字节码指令</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/101.png" alt=""></p>
<h3 id="84方法重写的本质">8.4、方法重写的本质</h3>
<blockquote>
<p><strong>动态语言和静态语言</strong></p>
</blockquote>
<ol>
<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li>
<li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Java：String info = &#34;mogu blog&#34;;     		(Java是静态类型语言的，会先编译就进行类型检查)JS：var name = &#34;shkstart&#34;;    var name = 10;	（运行时才进行检查）
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>方法重写的本质</strong></p>
</blockquote>
<p><strong>Java 语言中方法重写的本质：</strong></p>
<ol>
<li>
<p>找到操作数栈顶的第一个元素所执行的对象的<strong>实际类型</strong>，记作C。</p>
</li>
<li>
<p>如果</p>
<p>在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验</p>
<ul>
<li>如果通过则返回这个方法的直接引用，查找过程结束</li>
</ul>
</li>
</ol>
<ul>
<li>如果不通过，则返回java.1ang.IllegalAccessError 异常</li>
</ul>
<ol start="3">
<li>
<p>否则，<strong>按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程</strong>。</p>
</li>
<li>
<p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
</li>
</ol>
<hr>
<p><strong>IllegalAccessError介绍</strong></p>
<ol>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。</li>
<li>一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
<li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li>
</ol>
<hr>
<p><strong>回看解析阶段</strong></p>
<ol>
<li>解析阶段就是<strong>将常量池内的符号引用转换为直接引用的过程</strong></li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li>
</ol>
<h3 id="85多态与虚方法表">8.5、多态与虚方法表</h3>
<blockquote>
<p><strong>虚方法表</strong></p>
</blockquote>
<ol>
<li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能<strong>影响到执行效率</strong>。</li>
<li>因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表</strong>（virtual method table）来实现，非虚方法不会出现在表中。使用索引表来代替查找。</li>
<li><strong>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</strong>。</li>
<li>虚方法表是什么时候被创建的呢？<strong>虚方法表会在类加载的链接阶段被创建并开始初始化</strong>，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li>
<li>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/102.png" alt=""></p>
<h2 id="9方法返回地址">9、方法返回地址</h2>
<blockquote>
<p><strong>方法返回地址（return address）</strong></p>
</blockquote>
<ol>
<li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址</strong>，即调用该方法的指令的下一条指令的地址。而通过异常退出的，<strong>返回地址是要通过异常表来确定</strong>，栈帧中一般不会保存这部分信息。</li>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li>
<li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li>
</ol>
<blockquote>
<p><strong>方法退出的两种方式</strong></p>
</blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>
<hr>
<p><strong>正常退出：</strong></p>
<ol>
<li>
<p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
</li>
<li>
<p>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p>
</li>
<li>
<p>在字节码指令中，返回指令包含：</p>
<ol>
<li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li>
</ol>
</li>
<li>
<p>lreturn：Long类型
3. freturn：Float类型
4. dreturn：Double类型
5. areturn：引用类型
6. return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p>
</li>
</ol>
<hr>
<p><strong>异常退出：</strong></p>
<ol>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</li>
<li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/103.png" alt=""></p>
<blockquote>
<p>代码举例</p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReturnAddressTest</span> <span class="o">{</span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">methodBoolean</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">byte</span> <span class="nf">methodByte</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">short</span> <span class="nf">methodShort</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">char</span> <span class="nf">methodChar</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">methodInt</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">methodLong</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">float</span> <span class="nf">methodFloat</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="mi">0</span><span class="o">.</span><span class="na">0f</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">methodDouble</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="mi">0</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">methodString</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="n">Date</span> <span class="nf">methodDate</span><span class="o">()</span> <span class="o">{</span>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodVoid</span><span class="o">()</span> <span class="o">{</span>    <span class="o">}</span>    <span class="kd">static</span> <span class="o">{</span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method2</span><span class="o">()</span> <span class="o">{</span>        <span class="n">methodVoid</span><span class="o">();</span>        <span class="k">try</span> <span class="o">{</span>            <span class="n">method1</span><span class="o">();</span>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>        <span class="o">}</span>    <span class="o">}</span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>        <span class="n">FileReader</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="s">&#34;atguigu.txt&#34;</span><span class="o">);</span>        <span class="kt">char</span><span class="o">[]</span> <span class="n">cBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cBuffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>            <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">cBuffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>        <span class="o">}</span>        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>    <span class="o">}}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>方法正常返回
<ul>
<li>ireturn</li>
</ul>
</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/104.png" alt=""></p>
<ul>
<li>dreturn</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/105.png" alt=""></p>
<ul>
<li>areturn</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/106.png" alt=""></p>
<ul>
<li>异常处理表：
<ul>
<li>反编译字节码文件，可得到 Exception table</li>
<li>from ：字节码指令起始地址</li>
<li>to ：字节码指令结束地址</li>
<li>target ：出现异常跳转至地址为 11 的指令执行</li>
<li>type ：捕获异常的类型</li>
</ul>
</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/107.png" alt=""></p>
<h2 id="10一些附加信息">10、一些附加信息</h2>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="11栈相关面试题">11、栈相关面试题</h2>
<blockquote>
<p><strong>举例栈溢出的情况？（StackOverflowError）</strong></p>
</blockquote>
<p>通过 -Xss 设置栈的大小</p>
<blockquote>
<p><strong>调整栈大小，就能保证不出现溢出么？</strong></p>
</blockquote>
<p>不能保证不溢出</p>
<blockquote>
<p><strong>分配的栈内存越大越好么？</strong></p>
</blockquote>
<p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p>
<blockquote>
<p><strong>垃圾回收是否涉及到虚拟机栈？</strong></p>
</blockquote>
<p>不会</p>
<blockquote>
<p><strong>方法中定义的局部变量是否线程安全？</strong></p>
</blockquote>
<p><strong>何为线程安全？</strong></p>
<ol>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li>
</ol>
<p><strong>具体问题具体分析：</strong></p>
<ul>
<li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
<hr>
<ul>
<li>看代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/** * 面试题： * 方法中定义的局部变量是否线程安全？具体情况具体分析 * *   何为线程安全？ *      如果只有一个线程才可以操作此数据，则必是线程安全的。 *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 * @author shkstart * @create 2020 下午 7:48 */</span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringBuilderTest</span> <span class="o">{</span>    <span class="c1">//s1的声明方式是线程安全的    public static void method1(){        //StringBuilder:线程不安全        StringBuilder s1 = new StringBuilder();        s1.append(&#34;a&#34;);        s1.append(&#34;b&#34;);        //...    }    //sBuilder通过参数传递方法内，存在线程不安全的问题    public static void method2(StringBuilder sBuilder){        sBuilder.append(&#34;a&#34;);        sBuilder.append(&#34;b&#34;);        //...    }    //操作s1之后，将s1作为返回值返回，存在线程不安全的问题    public static StringBuilder method3(){        StringBuilder s1 = new StringBuilder();        s1.append(&#34;a&#34;);        s1.append(&#34;b&#34;);        return s1;    }    //s1的操作：是线程安全的    public static String method4(){        StringBuilder s1 = new StringBuilder();        s1.append(&#34;a&#34;);        s1.append(&#34;b&#34;);        return s1.toString();    }    public static void main(String[] args) {        StringBuilder s = new StringBuilder();        new Thread(() -&gt; {            s.append(&#34;a&#34;);            s.append(&#34;b&#34;);        }).start();        method2(s);    }}
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>运行时数据区，哪些部分存在Error和GC？</p>
</blockquote>
<table>
<thead>
<tr>
<th>运行时数据区</th>
<th>是否存在Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是（SOF）</td>
<td>否</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>方法区</td>
<td>是（OOM）</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>是（OOM）</td>
<td>是</td>
</tr>
</tbody>
</table>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">yuanshuai</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        0001-01-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/yuanshuai1122.github.io/tags/java/">Java</a>
          <a href="/yuanshuai1122.github.io/tags/jvm/">JVM</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC4%E7%AB%A0%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC4%E7%AB%A0%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JVM内存与垃圾回收篇第4章程序计数器</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC6%E7%AB%A0%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC6%E7%AB%A0%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/">
            <span class="next-text nav-default">JVM内存与垃圾回收篇第6章本地方法接口</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="yuanshuai1122.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>yuanshuai</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script>
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/yuanshuai1122.github.io/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
