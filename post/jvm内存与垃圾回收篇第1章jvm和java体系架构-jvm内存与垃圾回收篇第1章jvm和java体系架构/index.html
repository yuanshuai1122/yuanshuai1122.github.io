<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JVM内存与垃圾回收篇第1章JVM和Java体系架构 - 🧀 - 你好</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="yuanshuai" /><meta name="description" content="第 1 章 JVM 和 Java 体系架构 1、JVM 前言 作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直" /><meta name="keywords" content="blog, yuanshuai, yyss" />






<meta name="generator" content="Hugo 0.119.0 with theme even" />


<link rel="canonical" href="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC1%E7%AB%A0jvm%E5%92%8Cjava%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC1%E7%AB%A0jvm%E5%92%8Cjava%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/" />
<link rel="apple-touch-icon" sizes="180x180" href="/yuanshuai1122.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/yuanshuai1122.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/yuanshuai1122.github.io/favicon-16x16.png">
<link rel="manifest" href="/yuanshuai1122.github.io/manifest.json">
<link rel="mask-icon" href="/yuanshuai1122.github.io/safari-pinned-tab.svg" color="#5bbad5">



<link href="/yuanshuai1122.github.io/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JVM内存与垃圾回收篇第1章JVM和Java体系架构" />
<meta property="og:description" content="第 1 章 JVM 和 Java 体系架构 1、JVM 前言 作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直" />
<meta property="og:type" content="article" />
<meta property="og:url" content="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC1%E7%AB%A0jvm%E5%92%8Cjava%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC1%E7%AB%A0jvm%E5%92%8Cjava%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/" /><meta property="article:section" content="post" />


<meta itemprop="name" content="JVM内存与垃圾回收篇第1章JVM和Java体系架构">
<meta itemprop="description" content="第 1 章 JVM 和 Java 体系架构 1、JVM 前言 作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直">

<meta itemprop="wordCount" content="9971">
<meta itemprop="keywords" content="Java,JVM," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM内存与垃圾回收篇第1章JVM和Java体系架构"/>
<meta name="twitter:description" content="第 1 章 JVM 和 Java 体系架构 1、JVM 前言 作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">CNshuaiyuan</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="yuanshuai1122.github.io/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="yuanshuai1122.github.io/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="yuanshuai1122.github.io/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="yuanshuai1122.github.io/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">CNshuaiyuan</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="yuanshuai1122.github.io/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JVM内存与垃圾回收篇第1章JVM和Java体系架构</h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
          <span class="more-meta"> 约 9971 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第-1-章-jvm-和-java-体系架构">第 1 章 JVM 和 Java 体系架构</a>
      <ul>
        <li><a href="#1jvm-前言">1、JVM 前言</a></li>
        <li><a href="#2开发人员的病态">2、开发人员的病态</a></li>
        <li><a href="#3架构师在想甚么">3、架构师在想甚么</a></li>
        <li><a href="#4为什么学习-jvm">4、为什么学习 JVM</a></li>
        <li><a href="#5java-vs-c">5、Java VS C++</a></li>
        <li><a href="#6参考书籍">6、参考书籍</a></li>
        <li><a href="#7课程章节">7、课程章节</a></li>
        <li><a href="#8tiobe-排行榜">8、TIOBE 排行榜</a></li>
        <li><a href="#9java-生态圈">9、Java 生态圈</a></li>
        <li><a href="#10java的跨平台性">10、Java的跨平台性</a></li>
        <li><a href="#11字节码">11、字节码</a></li>
        <li><a href="#12多语言混合编程">12、多语言混合编程</a></li>
        <li><a href="#13自己写个-jvm">13、自己写个 JVM</a></li>
        <li><a href="#14java-重大事件">14、Java 重大事件</a></li>
        <li><a href="#15虚拟机介绍">15、虚拟机介绍</a>
          <ul>
            <li><a href="#151虚拟机概念">15.1、虚拟机概念</a></li>
            <li><a href="#152java-虚拟机">15.2、Java 虚拟机</a></li>
          </ul>
        </li>
        <li><a href="#16jvm-的位置">16、JVM 的位置</a></li>
        <li><a href="#17java-的整体结构">17、Java 的整体结构</a></li>
        <li><a href="#18java-代码执行流程">18、Java 代码执行流程</a></li>
        <li><a href="#19jvm-架构模型">19、JVM 架构模型</a>
          <ul>
            <li><a href="#191基于栈的指令集架构">19.1、基于栈的指令集架构</a></li>
            <li><a href="#192基于寄存器的指令级架构">19.2、基于寄存器的指令级架构</a></li>
            <li><a href="#193两种架构的举例">19.3、两种架构的举例</a></li>
            <li><a href="#195jvm-架构总结">19.5、JVM 架构总结</a></li>
          </ul>
        </li>
        <li><a href="#20jvm-生命周期">20、JVM 生命周期</a>
          <ul>
            <li><a href="#201虚拟机的启动">20.1、虚拟机的启动</a></li>
            <li><a href="#202虚拟机的执行">20.2、虚拟机的执行</a></li>
            <li><a href="#203虚拟机的退出">20.3、虚拟机的退出</a></li>
            <li><a href="#204查看虚拟机进程">20.4、查看虚拟机进程</a></li>
            <li><a href="#205exit-方法源码">20.5、exit() 方法源码</a></li>
          </ul>
        </li>
        <li><a href="#21jvm-发展历程">21、JVM 发展历程</a>
          <ul>
            <li><a href="#211sun-classic-vm">21.1、Sun Classic VM</a></li>
            <li><a href="#212exact-vm">21.2、Exact VM</a></li>
            <li><a href="#213hotspot-vm">21.3、HotSpot VM</a></li>
            <li><a href="#214jrockit">21.4、JRockit</a></li>
            <li><a href="#215ibm的j9">21.5、IBM的J9</a></li>
            <li><a href="#216kvm和cdc--cldc-hotspot">21.6、KVM和CDC / CLDC Hotspot</a></li>
            <li><a href="#217azul-vm">21.7、Azul VM</a></li>
            <li><a href="#218liquid-vm">21.8、Liquid VM</a></li>
            <li><a href="#219apache-marmony">21.9、Apache Marmony</a></li>
            <li><a href="#2110micorsoft-jvm">21.10、Micorsoft JVM</a></li>
            <li><a href="#2111taobao-jvm">21.11、Taobao JVM</a></li>
            <li><a href="#2112dalvik-vm">21.12、Dalvik VM</a></li>
            <li><a href="#2113graal-vm">21.13、Graal VM</a></li>
            <li><a href="#2114总结">21.14、总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="0001-01-01T00:00:00" title="January 1, 0001">January 1, 0001</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <h1 id="第-1-章-jvm-和-java-体系架构">第 1 章 JVM 和 Java 体系架构</h1>
<h2 id="1jvm-前言">1、JVM 前言</h2>
<p>作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p>
<ol>
<li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li>
<li>想解决线上JVM GC问题，但却无从下手。</li>
<li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就GG了</li>
<li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/1.png" alt=""></p>
<h2 id="2开发人员的病态">2、开发人员的病态</h2>
<ol>
<li>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</li>
<li>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</li>
<li>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/2.png" alt=""></p>
<h2 id="3架构师在想甚么">3、架构师在想甚么</h2>
<p><strong>架构师每天都在思考什么？</strong></p>
<ol>
<li>应该如何让我的系统更快？</li>
<li>如何避免系统出现瓶颈？</li>
</ol>
<hr>
<p><strong>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</strong></p>
<ol>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定技术方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li>
</ol>
<h2 id="4为什么学习-jvm">4、为什么学习 JVM</h2>
<ol>
<li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li>
<li>中高级程序员必备技能：项目管理、调优的需求</li>
<li>追求极客的精神，比如：垃圾回收算法、JIT（即时编译器）、底层原理</li>
</ol>
<h2 id="5java-vs-c">5、Java VS C++</h2>
<ol>
<li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li>
<li>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/3.png" alt=""></p>
<h2 id="6参考书籍">6、参考书籍</h2>
<p><strong>英文文档规范</strong>：https://docs.oracle.com/javase/specs/index.html</p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/4.png" alt=""></p>
<p><strong>中文书籍：</strong></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/5.png" alt=""></p>
<h2 id="7课程章节">7、课程章节</h2>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/6.png" alt=""></p>
<h2 id="8tiobe-排行榜">8、TIOBE 排行榜</h2>
<p><strong>TIOBE 排行榜</strong>：https://www.tiobe.com/tiobe-index/</p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/7.png" alt=""></p>
<h2 id="9java-生态圈">9、Java 生态圈</h2>
<p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ol>
<li>作为一个平台，Java虚拟机扮演着举足轻重的作用
<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li>作为一种文化，Java几乎成为了“开源”的代名词。
<ul>
<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>
<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>
</ul>
</li>
<li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li>
</ol>
<h2 id="10java的跨平台性">10、Java的跨平台性</h2>
<ol>
<li>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</li>
<li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li>
<li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/8.png" alt=""></p>
<h2 id="11字节码">11、字节码</h2>
<ol>
<li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</li>
<li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</li>
<li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/9.png" alt=""></p>
<h2 id="12多语言混合编程">12、多语言混合编程</h2>
<ol>
<li>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li>
<li>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</li>
<li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</li>
</ol>
<h2 id="13自己写个-jvm">13、自己写个 JVM</h2>
<ol>
<li>Java虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！</li>
<li>自己动手写一个Java虚拟机，难吗？</li>
<li>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣</li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/10.png" alt=""></p>
<h2 id="14java-重大事件">14、Java 重大事件</h2>
<ul>
<li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为Oak，后期命名为Java</li>
<li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li>
<li>1996年1月23日Sun Microsystems发布了JDK 1.0。</li>
<li>1998年，JDK1.2版本发布。同时，Sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li>
<li>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li>
<li>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li>
<li>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li>
<li>2006年，JDK6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li>
<li>2007年，Java平台迎来了新伙伴Clojure。</li>
<li>2008年，oracle收购了BEA，得到了JRockit虚拟机。</li>
<li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。</li>
<li>2010年，Oracle收购了Sun，获得Java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</li>
<li>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li>
<li>2017年，JDK9发布。将G1设置为默认GC，替代CMS</li>
<li>同年，IBM的J9开源，形成了现在的Open J9社区</li>
<li>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li>
<li>同年，Oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li>
<li>同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可</li>
<li>2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/11.png" alt=""></p>
<h2 id="15虚拟机介绍">15、虚拟机介绍</h2>
<h3 id="151虚拟机概念">15.1、虚拟机概念</h3>
<p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ol>
<li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
<li>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</li>
</ol>
<h3 id="152java-虚拟机">15.2、Java 虚拟机</h3>
<ol>
<li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li>
<li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li>
<li>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li>
<li>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ol>
<h2 id="16jvm-的位置">16、JVM 的位置</h2>
<p><strong>JVM是运行在操作系统之上的，它与硬件没有直接的交互</strong></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/12.png" alt=""></p>
<p><strong>Java的体系结构</strong></p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/13.png" alt=""></p>
<h2 id="17java-的整体结构">17、Java 的整体结构</h2>
<ol>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用<strong>解释器与即时编译器并存的架构</strong>。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li>
<li><strong>执行引擎包含三部分：解释器，即时编译器，垃圾回收器</strong></li>
</ol>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/14.png" alt=""></p>
<h2 id="18java-代码执行流程">18、Java 代码执行流程</h2>
<p>凡是能生成被Java虚拟机所能解释、运行的字节码文件，那么理论上我们就可以自己设计一套语言了</p>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/15.png" alt=""></p>
<h2 id="19jvm-架构模型">19、JVM 架构模型</h2>
<p><strong>Java编译器输入的指令流基本上是一种基于栈的指令集架构</strong>，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<h3 id="191基于栈的指令集架构">19.1、基于栈的指令集架构</h3>
<p><strong>基于栈式架构的特点：</strong></p>
<ol>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li><strong>避开了寄存器的分配难题：使用零地址指令方式分配</strong></li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。<strong>指令集更小，编译器容易实现</strong></li>
<li><strong>不需要硬件支持，可移植性更好，更好实现跨平台</strong></li>
</ol>
<h3 id="192基于寄存器的指令级架构">19.2、基于寄存器的指令级架构</h3>
<p><strong>基于寄存器架构的特点：</strong></p>
<ol>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li><strong>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</strong></li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，<strong>基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主</strong>，而基于栈式架构的指令集却是以零地址指令为主</li>
</ol>
<h3 id="193两种架构的举例">19.3、两种架构的举例</h3>
<p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<ul>
<li><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackStruTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在 .class 文件的同级目录下，执行反编译</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/16.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">javap -v StackStruTest.class
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>反编译得到的指令</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">descriptor</span><span class="o">:</span> <span class="o">([</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span><span class="o">,</span> <span class="n">ACC_STATIC</span>
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">stack</span><span class="o">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="mi">4</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">0</span><span class="o">:</span> <span class="n">iconst_2</span>	<span class="c1">// 将常量 2 压入栈中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">1</span><span class="o">:</span> <span class="n">istore_1</span>	<span class="c1">// 将常量 2 保存至变量 i 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">2</span><span class="o">:</span> <span class="n">iconst_3</span>	<span class="c1">// 将常量 3 压入栈中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">3</span><span class="o">:</span> <span class="n">istore_2</span>	<span class="c1">// 将常量 3 保存至变量 j 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">4</span><span class="o">:</span> <span class="n">iload_1</span>		<span class="c1">// 加载变量 i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">5</span><span class="o">:</span> <span class="n">iload_2</span>		<span class="c1">// 加载变量 j
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">6</span><span class="o">:</span> <span class="n">iadd</span>		<span class="c1">// 执行累加操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">7</span><span class="o">:</span> <span class="n">istore_3</span>	<span class="c1">// 加法结果保存在变量 k 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">8</span><span class="o">:</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl">      <span class="n">LineNumberTable</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">10</span><span class="o">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">11</span><span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">12</span><span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">22</span><span class="o">:</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">      <span class="n">LocalVariableTable</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">Start</span>  <span class="n">Length</span>  <span class="n">Slot</span>  <span class="n">Name</span>   <span class="n">Signature</span>
</span></span><span class="line"><span class="cl">            <span class="mi">0</span>       <span class="mi">9</span>     <span class="mi">0</span>  <span class="n">args</span>   <span class="o">[</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="mi">2</span>       <span class="mi">7</span>     <span class="mi">1</span>     <span class="n">i</span>   <span class="n">I</span>
</span></span><span class="line"><span class="cl">            <span class="mi">4</span>       <span class="mi">5</span>     <span class="mi">2</span>     <span class="n">j</span>   <span class="n">I</span>
</span></span><span class="line"><span class="cl">            <span class="mi">8</span>       <span class="mi">1</span>     <span class="mi">3</span>     <span class="n">k</span>   <span class="n">I</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="195jvm-架构总结">19.5、JVM 架构总结</h3>
<ol>
<li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</strong></li>
<li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</li>
<li>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li>
</ol>
<h2 id="20jvm-生命周期">20、JVM 生命周期</h2>
<h3 id="201虚拟机的启动">20.1、虚拟机的启动</h3>
<p><strong>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的</strong>，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="202虚拟机的执行">20.2、虚拟机的执行</h3>
<ol>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时他就停止</li>
<li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li>
</ol>
<h3 id="203虚拟机的退出">20.3、虚拟机的退出</h3>
<p><strong>有如下的几种情况：</strong></p>
<ol>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统用现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li>
</ol>
<h3 id="204查看虚拟机进程">20.4、查看虚拟机进程</h3>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackStruTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">6000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>趁程序还在运行的时候，赶快使用 <strong>jps</strong> 指令查看当前正在运行的进程，图中 23756 为进程所占用的端口号</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/17.png" alt=""></p>
<ul>
<li>StackStruTest 进行执行完毕，就查看不到咯</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/18.png" alt=""></p>
<h3 id="205exit-方法源码">20.5、exit() 方法源码</h3>
<blockquote>
<p><strong>Runtime 类源码分析</strong></p>
</blockquote>
<ul>
<li>Runtime 对象全局唯一，对应着下图中的【运行时数据区】</li>
</ul>
<p><img src="https://hexobbblog.oss-cn-beijing.aliyuncs.com/images/jvm_first/19.png" alt=""></p>
<ul>
<li>明显的饿汉设计模式：一上来就 new 了一个 Runtime 类的实例，并且将 Runtime 类的构造器私有化了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Runtime</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Runtime</span> <span class="n">currentRuntime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runtime</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Returns the runtime object associated with the current Java application.
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance
</span></span></span><span class="line"><span class="cl"><span class="cm">     * methods and must be invoked with respect to the current runtime object.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current
</span></span></span><span class="line"><span class="cl"><span class="cm">     *          Java application.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Runtime</span> <span class="nf">getRuntime</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">currentRuntime</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** Don&#39;t let anyone else instantiate this class */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Runtime</span><span class="o">()</span> <span class="o">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Runtime 类的 exit() 方法调用了 ShutDown 类的 exit() 方法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">exit</span><span class="o">(</span><span class="kt">int</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SecurityManager</span> <span class="n">security</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">security</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">security</span><span class="o">.</span><span class="na">checkExit</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Shutdown</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>ShutDown 类源码分析</strong></p>
</blockquote>
<ul>
<li>exit() 方法会调用到本地方法 runAllFinalizers() 和 halt0()</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">exit</span><span class="o">(</span><span class="kt">int</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">boolean</span> <span class="n">runMoreFinalizers</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">runFinalizersOnExit</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="o">(</span><span class="n">state</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="n">RUNNING</span><span class="o">:</span>       <span class="cm">/* Initiate shutdown */</span>
</span></span><span class="line"><span class="cl">                <span class="n">state</span> <span class="o">=</span> <span class="n">HOOKS</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="n">HOOKS</span><span class="o">:</span>         <span class="cm">/* Stall and halt */</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="n">FINALIZERS</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* Halt immediately on nonzero status */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">halt</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* Compatibility with old behavior:
</span></span></span><span class="line"><span class="cl"><span class="cm">                     * Run more finalizers and then halt
</span></span></span><span class="line"><span class="cl"><span class="cm">                     */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">runMoreFinalizers</span> <span class="o">=</span> <span class="n">runFinalizersOnExit</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">runMoreFinalizers</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">runAllFinalizers</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">halt</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Shutdown</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Synchronize on the class object, causing any other thread
</span></span></span><span class="line"><span class="cl"><span class="cm">             * that attempts to initiate shutdown to stall indefinitely
</span></span></span><span class="line"><span class="cl"><span class="cm">             */</span>
</span></span><span class="line"><span class="cl">        <span class="n">sequence</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">halt</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">halt</span><span class="o">(</span><span class="kt">int</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">haltLock</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">halt0</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">halt0</span><span class="o">(</span><span class="kt">int</span> <span class="n">status</span><span class="o">);</span><span class="cm">/* Wormhole for invoking java.lang.ref.Finalizer.runAllFinalizers */</span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">runAllFinalizers</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>System 类源码分析</strong></p>
</blockquote>
<ul>
<li>System.exit() 方法调用了 Runtime.exit() 方法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">exit</span><span class="o">(</span><span class="kt">int</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>    <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exit</span><span class="o">(</span><span class="n">status</span><span class="o">);}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>总结</strong></p>
</blockquote>
<ol>
<li>调用 System.exit() 方法 &ndash;&gt; 调用 Runtime.exit() 方法</li>
<li>调用 Runtime.exit() 方法 &ndash;&gt; 调用了 ShutDown.exit() 方法</li>
</ol>
<h2 id="21jvm-发展历程">21、JVM 发展历程</h2>
<h3 id="211sun-classic-vm">21.1、Sun Classic VM</h3>
<ol>
<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li>
<li>这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低，即时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在Hotspot内置了此虚拟机。</li>
</ol>
<h3 id="212exact-vm">21.2、Exact VM</h3>
<ol>
<li>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</li>
<li>Exact Memory Management：准确式内存管理
<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li>
</ul>
</li>
<li>具备现代高性能虚拟机的维形
<ul>
<li>热点探测（寻找出热点代码进行缓存）</li>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li>只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</li>
</ol>
<h3 id="213hotspot-vm">21.3、HotSpot VM</h3>
<ol>
<li>
<p>HotSpot历史</p>
<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</li>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
</li>
<li>
<p>目前Hotspot占有绝对的市场地位，称霸武林。</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>
<li>Sun/oracle JDK和openJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
</li>
<li>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
</li>
<li>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>
<p>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</p>
</li>
<li>
<p>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p>
</li>
</ul>
</li>
</ol>
<h3 id="214jrockit">21.4、JRockit</h3>
<ol>
<li>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
<li>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li>
<li>优势：全面的Java运行时解决方案组合
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
</li>
<li>2008年，JRockit被Oracle收购。</li>
<li>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</li>
<li>高斯林：目前就职于谷歌，研究人工智能和水下机器人</li>
</ol>
<h3 id="215ibm的j9">21.5、IBM的J9</h3>
<ol>
<li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li>
<li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</li>
<li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</li>
<li>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</li>
<li>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</li>
</ol>
<h3 id="216kvm和cdc--cldc-hotspot">21.6、KVM和CDC / CLDC Hotspot</h3>
<ol>
<li>Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Android和iOS二分天下。</li>
<li>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
<li>所有的虚拟机的原则：一次编译，到处运行。</li>
</ol>
<h3 id="217azul-vm">21.7、Azul VM</h3>
<ol>
<li>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azul VW和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。</li>
<li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li>
<li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li>
<li>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li>
</ol>
<h3 id="218liquid-vm">21.8、Liquid VM</h3>
<ol>
<li>高性能Java虚拟机中的战斗机。</li>
<li>BEA公司开发的，直接运行在自家Hypervisor系统上</li>
<li>Liquid VM即是现在的JRockit VE（Virtual Edition）</li>
<li>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li>
<li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li>
</ol>
<h3 id="219apache-marmony">21.9、Apache Marmony</h3>
<ol>
<li>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</li>
<li>它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</li>
<li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</li>
</ol>
<h3 id="2110micorsoft-jvm">21.10、Micorsoft JVM</h3>
<ol>
<li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</li>
<li>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</li>
<li>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</li>
</ol>
<h3 id="2111taobao-jvm">21.11、Taobao JVM</h3>
<ol>
<li>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</li>
<li>基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</li>
<li>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。
<ul>
<li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li>
<li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li>
<li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助功能</li>
<li>针对大数据场景的ZenGC</li>
</ul>
</li>
<li>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</li>
<li>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</li>
</ol>
<h3 id="2112dalvik-vm">21.12、Dalvik VM</h3>
<ol>
<li>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</li>
<li>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</li>
<li>不能直接执行Java的Class文件</li>
<li>基于寄存器架构，不是jvm的栈架构。</li>
<li>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</li>
<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>
<li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li>
</ol>
<h3 id="2113graal-vm">21.13、Graal VM</h3>
<ol>
<li>2018年4月，Oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere&quot;遥相呼应。</li>
<li>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”
的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li>
<li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li>
<li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li>
<li>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</li>
</ol>
<h3 id="2114总结">21.14、总结</h3>
<p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">yuanshuai</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        0001-01-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/yuanshuai1122.github.io/tags/java/">Java</a>
          <a href="/yuanshuai1122.github.io/tags/jvm/">JVM</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC17%E7%AB%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC17%E7%AB%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JVM内存与垃圾回收篇第17章垃圾回收器</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="yuanshuai1122.github.io/post/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC2%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F-jvm%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87%E7%AC%AC2%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/">
            <span class="next-text nav-default">JVM内存与垃圾回收篇第2章类加载子系统</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="yuanshuai1122.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>yuanshuai</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script>
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/yuanshuai1122.github.io/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
